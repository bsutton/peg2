part of '../../generators.dart';

class ParserGenerator {
  static const _classes = '''
  class _Buffer<K, V> {
  List<K> keys;

  int length;

  int pos;

  final int size;

  List<V> values;

  _Buffer(this.size) {
    keys = List(size);
    values = List(size);
    length = 0;
    pos = 0;
  }

  void add(K key, V value) {
    keys[pos] = key;
    values[pos] = value;
    if (++pos >= size) {
      pos = 0;
    }

    if (length < size) {
      length++;
    }
  }

  K find(V value) {
    var index = pos - 1;
    var count = length;
    while (count-- > 0) {
      final v = values[index];
      if (v == value) {
        return keys[index];
      }

      if (++index > size) {
        index = 0;
      }
    }

    return null;
  }
}

class _Memo {
  final int id;

  final int pos;

  final result;

  final bool success;

  _Memo({
    this.id,
    this.pos,
    this.result,
    this.success,
  });
}

''';

  String generate(Grammar grammar, ParserGeneratorOptions options) {
    final grammarAnalyzer = GrammarAnalyzer();
    final grammarErrors = grammarAnalyzer.analyze(grammar);
    if (grammarErrors.isNotEmpty) {
      for (var error in grammarErrors) {
        print(error);
      }

      return null;
    }

    final rulesToOperationsBuilder = RulesToOperationsBuilder();
    final methods = rulesToOperationsBuilder.build(grammar, options);
    for (final method in methods) {
      final operationsInitializer = OperationInitializer();
      operationsInitializer.initialize(method);
    }

    for (final method in methods) {
      final operationsOptimizer = OperationOptimizer();
      operationsOptimizer.optimize(method.body);
    }

    final operationsToCodeConverter = OperationsToCodeConverter();
    final methodBuilders = operationsToCodeConverter.convert(methods);
    final libraryBuilder = ContentBuilder();
    _addHeader(libraryBuilder, options);
    final lineSplitter = LineSplitter();
    if (grammar.globals != null) {
      final lines = lineSplitter.convert(grammar.globals);
      if (lines.isNotEmpty && lines[0].isEmpty) {
        lines.removeAt(0);
      }

      libraryBuilder.addAll(lines);
    }

    final parserClassBuilder = ParserClassBuilder();
    final name = options.name + 'Parser';
    parserClassBuilder.build(grammar, name, libraryBuilder, methodBuilders);
    final classes = lineSplitter.convert(_classes);
    libraryBuilder.addAll(classes);
    libraryBuilder.add('// ignore_for_file: prefer_final_locals');
    libraryBuilder.add('// ignore_for_file: unused_element');
    libraryBuilder.add('// ignore_for_file: unused_field');
    libraryBuilder.add('// ignore_for_file: unused_local_variable');
    final formatter = DartFormatter();
    var source = libraryBuilder.build(0).join('\n');
    try {
      source = formatter.format(source);
      // ignore: unused_catch_clause
    } on FormatterException catch (e) {
      //
    }

    return source;
  }

  void _addHeader(ContentBuilder builder, ParserGeneratorOptions options) {
    /*
    builder.add('// Generated by \'peg2\'');
    builder.add('// Version: ');
    builder.add('// https://pub.dev/packages/peg2');
    builder.add('// Options:');
    builder.add('//   inlineNonterminals: ${options.inlineNonterminals}');
    builder.add('//   inlineSubterminals: ${options.inlineSubterminals}');
    builder.add('//   memoize: ${options.memoize}');
    builder.add('');
    */
  }
}
