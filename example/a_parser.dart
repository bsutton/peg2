// Generated by 'peg2'
// https://pub.dev/packages/peg2

part of '../../query_parser.dart';

Expression _buildAssignable(Expression expression, List selectors) {
  var result = expression;
  for (final element in selectors) {
    if (element is ArgumentsExpression) {
      result = CallExpression(result, element);
    } else {
      final kind = element[0];
      final value = element[1];
      if (kind == '[') {
        result = IndexerExpression(result, value as Expression);
      } else if (kind == '.') {
        result = MemberAccessExpression(result, value as IdentifierExpression);
      } else {
        throw StateError('Incorrect assignable selector: $element');
      }
    }
  }

  return result;
}

Expression _buildBinary(Expression head, List<List> tail) {
  Expression builder(Expression head, List tail) {
    final left = head;
    final right = tail[1] as Expression;
    final operator = tail[0] as String;
    return Expression.binary(operator, left, right);
  }

  return _buildTree(head, tail, builder);
}

Expression _buildTree(Expression head, List<List> tail,
    Expression Function(Expression head, List tail) builder) {
  var result = head;
  for (var i = 0; i < tail.length; i++) {
    result = builder(result, tail[i]);
  }

  return result;
}

Expression _postUnary(String operator, Expression expression) {
  if (operator == null) {
    return expression;
  }

  ExpressionKind kind;
  switch (operator) {
    case '--':
      kind = ExpressionKind.postDecrement;
      break;
    case '++':
      kind = ExpressionKind.postIncrement;
      break;
    default:
      throw StateError('Inavlid operator: $operator');
  }

  return UnaryExpression(kind, expression);
}

Expression _unary(String operator, Expression expression) {
  if (operator == null) {
    return expression;
  }

  ExpressionKind kind;
  switch (operator) {
    case '~':
      kind = ExpressionKind.bitwiseNot;
      break;
    case '!':
      kind = ExpressionKind.not;
      break;
    case '--':
      kind = ExpressionKind.preDecrement;
      break;
    case '++':
      kind = ExpressionKind.preIncrement;
      break;
    case '-':
      kind = ExpressionKind.unaryMinus;
      break;
    default:
      throw StateError('Inavlid operator: $operator');
  }

  return UnaryExpression(kind, expression);
}

class AParser {
  static const _eof = 0x110000;

  FormatException error;

  int _c;

  int _error;

  List<String> _expected;

  int _failure;

  List<int> _input;

  List<List<_Memo>> _memos;

  var _mresult;

  int _pos;

  bool _predicate;

  dynamic _result;

  bool _success;

  String _text;

  dynamic parse(String text) {
    if (text == null) {
      throw ArgumentError.notNull('text');
    }
    _text = text;
    _input = _toRunes(text);
    _reset();
    final result = _parseQueryExpression(false, true);
    _buildError();
    _expected = null;
    _input = null;
    return result;
  }

  void _buildError() {
    if (_success) {
      error = null;
      return;
    }

    String escape(int c) {
      switch (c) {
        case 10:
          return r'\n';
        case 13:
          return r'\r';
        case 09:
          return r'\t';
        case _eof:
          return 'end of file';
      }
      return String.fromCharCode(c);
    }

    String getc(int position) {
      if (position < _text.length) {
        return "'${escape(_input[position])}'";
      }
      return 'end of file';
    }

    String report(String message, String source, int start) {
      if (start < 0 || start > source.length) {
        start = null;
      }

      final sb = StringBuffer();
      sb.write(message);
      var line = 0;
      var col = 0;
      var lineStart = 0;
      var started = false;
      if (start != null) {
        for (var i = 0; i < source.length; i++) {
          final c = source.codeUnitAt(i);
          if (!started) {
            started = true;
            lineStart = i;
            line++;
            col = 1;
          } else {
            col++;
          }
          if (c == 10) {
            started = false;
          }
          if (start == i) {
            break;
          }
        }
      }

      if (start == null) {
        sb.writeln('.');
      } else if (line == 0 || start == source.length) {
        sb.write(' (at offset ');
        sb.write(start);
        sb.writeln('):');
      } else {
        sb.write(' (at line ');
        sb.write(line);
        sb.write(', column ');
        sb.write(col);
        sb.writeln('):');
      }

      List<int> escape(int c) {
        switch (c) {
          case 9:
            return [92, 116];
          case 10:
            return [92, 110];
          case 13:
            return [92, 114];
          default:
            return [c];
        }
      }

      const max = 70;
      if (start != null) {
        final c1 = <int>[];
        final c2 = <int>[];
        final half = max ~/ 2;
        var cr = false;
        for (var i = start; i >= lineStart && c1.length < half; i--) {
          if (i == source.length) {
            c2.insert(0, 94);
          } else {
            final c = source.codeUnitAt(i);
            final escaped = escape(c);
            c1.insertAll(0, escaped);
            if (c == 10) {
              cr = true;
            }

            final r = i == start ? 94 : 32;
            for (var k = 0; k < escaped.length; k++) {
              c2.insert(0, r);
            }
          }
        }

        for (var i = start + 1;
            i < source.length && c1.length < max && !cr;
            i++) {
          final c = source.codeUnitAt(i);
          final escaped = escape(c);
          c1.addAll(escaped);
          if (c == 10) {
            break;
          }
        }

        final text1 = String.fromCharCodes(c1);
        final text2 = String.fromCharCodes(c2);
        sb.writeln(text1);
        sb.writeln(text2);
      }

      return sb.toString();
    }

    final temp = _expected.toList();
    temp.sort((e1, e2) => e1.compareTo(e2));
    final expected = temp.toSet();
    final hasMalformed = false;
    if (expected.isNotEmpty) {
      if (!hasMalformed) {
        final sb = StringBuffer();
        sb.write('Expected ');
        sb.write(expected.join(', '));
        sb.write(' but found ');
        sb.write(getc(_error));
        final title = sb.toString();
        final message = report(title, _text, _error);
        error = FormatException(message);
      } else {
        final reason = _error == _text.length ? 'Unterminated' : 'Malformed';
        final sb = StringBuffer();
        sb.write(reason);
        sb.write(' ');
        sb.write(expected.join(', '));
        final title = sb.toString();
        final message = report(title, _text, _error);
        error = FormatException(message);
      }
    } else {
      final sb = StringBuffer();
      sb.write('Unexpected character ');
      sb.write(getc(_error));
      final title = sb.toString();
      final message = report(title, _text, _error);
      error = FormatException(message);
    }
  }

  void _fail(List<String> expected) {
    if (_error < _failure) {
      _error = _failure;
      _expected = [];
    }
    if (_error == _failure) {
      _expected.addAll(expected);
    }
  }

  int _matchChar(int c) {
    int result;
    if (c == _c) {
      _success = true;
      _c = _input[_pos += _c <= 0xffff ? 1 : 2];
      result = c;
    } else {
      _success = false;
      _failure = _pos;
    }

    return result;
  }

  int _matchRanges(List<int> ranges) {
    int result;
    _success = false;
    for (var i = 0; i < ranges.length; i += 2) {
      if (ranges[i] <= _c) {
        if (ranges[i + 1] >= _c) {
          result = _c;
          _c = _input[_pos += _c <= 0xffff ? 1 : 2];
          _success = true;
          break;
        }
      } else {
        break;
      }
    }

    if (!_success) {
      _failure = _pos;
    }

    return result;
  }

  String _matchString(String text) {
    String result;
    final length = text.length;
    final rest = _text.length - _pos;
    final count = length > rest ? rest : length;
    var pos = _pos;
    var i = 0;
    for (; i < count; i++, pos++) {
      if (text.codeUnitAt(i) != _text.codeUnitAt(pos)) {
        break;
      }
    }

    if (_success = i == length) {
      _c = _input[_pos += length];
      result = text;
    } else {
      _failure = _pos + i;
    }

    return result;
  }

  bool _memoized(int id) {
    final memos = _memos[_pos];
    if (memos != null) {
      for (var i = 0; i < memos.length; i++) {
        final memo = memos[i];
        if (memo.id == id) {
          _pos = memo.pos;
          _mresult = memo.result;
          _success = memo.success;
          _c = _input[_pos];
          return true;
        }
      }
    }

    return false;
  }

  void _memoize(int id, int pos, result) {
    var memos = _memos[pos];
    if (memos == null) {
      memos = [];
      _memos[pos] = memos;
    }

    final memo = _Memo(
      id: id,
      pos: _pos,
      result: result,
      success: _success,
    );

    memos.add(memo);
  }

  void _reset() {
    _c = _input[0];
    _error = 0;
    _expected = [];
    _failure = -1;
    _memos = [];
    _memos.length = _input.length + 1;
    _pos = 0;
    _predicate = false;
    _success = false;
  }

  List<int> _toRunes(String source) {
    final length = source.length;
    final result = List<int>(length + 1);
    for (var pos = 0; pos < length;) {
      int c;
      final start = pos;
      final leading = source.codeUnitAt(pos++);
      if ((leading & 0xFC00) == 0xD800 && pos < length) {
        final trailing = source.codeUnitAt(pos);
        if ((trailing & 0xFC00) == 0xDC00) {
          c = 0x10000 + ((leading & 0x3FF) << 10) + (trailing & 0x3FF);
          pos++;
        } else {
          c = leading;
        }
      } else {
        c = leading;
      }

      result[start] = c;
    }

    result[length] = 0x110000;
    return result;
  }

  QueryExpression _parseQueryExpression(bool $0, bool $1) {
    QueryExpression $2;
    final $3 = _pos;
    final $4 = _c;
    QueryExpression $6;
    _parse_leading_spaces(false, false);
    final $11 = _parseFromClause(true, $1);
    if (_success) {
      final $12 = _parseQueryBody(true, $1);
      if (_success) {
        _parse_end_of_file(false, false);
        if (_success) {
          final f = $11;
          final b = $12;
          QueryExpression $$;
          $$ = QueryExpression(f, b);
          $6 = $$;
        }
      }
    }
    if (!_success) {
      _c = $4;
      _pos = $3;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'from\'']);
    }
    return $2;
  }

  FromClause _parseFromClause(bool $0, bool $1) {
    FromClause $2;
    final $3 = _pos;
    final $4 = _c;
    FromClause $6;
    _parse_from(false, false);
    if (_success) {
      final $10 = _parseParameter(false, $1);
      if (_success) {
        _parse_in(false, false);
        if (_success) {
          final $12 = _parseExpression(false, $1);
          if (_success) {
            final v = $10;
            final s = $12;
            FromClause $$;
            $$ = FromClause(v, s);
            $6 = $$;
          }
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'from\'']);
    }
    return $2;
  }

  QueryBody _parseQueryBody(bool $0, bool $1) {
    QueryBody $2;
    final $3 = _pos;
    QueryBody $6;
    final $9 = _parseQueryBodyClauses(false, $1);
    final $10 = $9;
    final $11 = _parseSelectOrGroupClause(false, $1);
    if (_success) {
      final $12 = _parseQueryContinuation(false, $1);
      final $13 = $12;
      _success = true;
      final b = $10;
      final s = $11;
      final c = $13;
      QueryBody $$;
      $$ = QueryBody(b, s, c);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'select\'', '\'group\'']);
    }
    return $2;
  }

  List<QueryBodyClause> _parseQueryBodyClauses(bool $0, bool $1) {
    List<QueryBodyClause> $2;
    final $3 = _pos;
    List<QueryBodyClause> $6;
    List<QueryBodyClause> $9;
    if ($1) {
      $9 = [];
    }
    var $10 = false;
    for (;;) {
      final $11 = _parseQueryBodyClause(false, $1);
      if (!_success) {
        _success = $10;
        if (!_success) {
          $9 = null;
        }
        break;
      }
      if ($1) {
        $9.add($11);
      }
      $10 = true;
    }
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'from\'',
        '\'let\'',
        '\'where\'',
        '\'join\'',
        '\'orderby\''
      ]);
    }
    return $2;
  }

  QueryBodyClause _parseQueryBodyClause(bool $0, bool $1) {
    QueryBodyClause $2;
    final $3 = _pos;
    for (;;) {
      QueryBodyClause $6;
      final $9 = _parseFromClause(true, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      QueryBodyClause $10;
      final $13 = _parseLetClause(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      QueryBodyClause $14;
      final $17 = _parseWhereClause(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      QueryBodyClause $18;
      final $21 = _parseJoinClause(false, $1);
      if (_success) {
        $18 = $21;
        $2 = $18;
        break;
      }
      QueryBodyClause $22;
      final $25 = _parseJoinIntoClause(false, $1);
      if (_success) {
        $22 = $25;
        $2 = $22;
        break;
      }
      QueryBodyClause $26;
      final $29 = _parseOrderbyClause(false, $1);
      if (_success) {
        $26 = $29;
        $2 = $26;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'from\'',
        '\'let\'',
        '\'where\'',
        '\'join\'',
        '\'orderby\''
      ]);
    }
    return $2;
  }

  LetClause _parseLetClause(bool $0, bool $1) {
    LetClause $2;
    final $3 = _pos;
    final $4 = _c;
    LetClause $6;
    _parse_let(false, false);
    if (_success) {
      final $10 = _parseParameter(true, $1);
      if (_success) {
        _parse_$EqualSign(true, false);
        if (_success) {
          final $12 = _parseExpression(true, $1);
          if (_success) {
            final i = $10;
            final e = $12;
            LetClause $$;
            $$ = LetClause(i, e);
            $6 = $$;
          }
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'let\'']);
    }
    return $2;
  }

  WhereClause _parseWhereClause(bool $0, bool $1) {
    WhereClause $2;
    final $3 = _pos;
    final $4 = _c;
    WhereClause $6;
    _parse_where(false, false);
    if (_success) {
      final $10 = _parseExpression(true, $1);
      if (_success) {
        final p = $10;
        WhereClause $$;
        $$ = WhereClause(p);
        $6 = $$;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'where\'']);
    }
    return $2;
  }

  JoinClause _parseJoinClause(bool $0, bool $1) {
    JoinClause $2;
    final $3 = _pos;
    final $4 = _c;
    JoinClause $6;
    _parse_join(true, false);
    if (_success) {
      final $10 = _parseParameter(true, $1);
      if (_success) {
        _parse_in(true, false);
        if (_success) {
          final $12 = _parseExpression(false, $1);
          if (_success) {
            _parse_on(true, false);
            if (_success) {
              final $14 = _parseExpression(false, $1);
              if (_success) {
                _parse_equals(true, false);
                if (_success) {
                  final $16 = _parseExpression(false, $1);
                  if (_success) {
                    final j = $10;
                    final i = $12;
                    final o = $14;
                    final e = $16;
                    JoinClause $$;
                    $$ = JoinClause(j, i, o, e);
                    $6 = $$;
                  }
                }
              }
            }
          }
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'join\'']);
    }
    return $2;
  }

  JoinIntoClause _parseJoinIntoClause(bool $0, bool $1) {
    JoinIntoClause $2;
    final $3 = _pos;
    final $4 = _c;
    JoinIntoClause $6;
    _parse_join(true, false);
    if (_success) {
      final $10 = _parseParameter(true, $1);
      if (_success) {
        _parse_in(true, false);
        if (_success) {
          final $12 = _parseExpression(false, $1);
          if (_success) {
            _parse_on(true, false);
            if (_success) {
              final $14 = _parseExpression(false, $1);
              if (_success) {
                _parse_equals(true, false);
                if (_success) {
                  final $16 = _parseExpression(false, $1);
                  if (_success) {
                    _parse_into(true, false);
                    if (_success) {
                      final $18 = _parse_identifier(true, $1);
                      if (_success) {
                        final j = $10;
                        final i = $12;
                        final o = $14;
                        final e = $16;
                        final n = $18;
                        JoinIntoClause $$;
                        $$ = JoinIntoClause(j, i, o, e, n);
                        $6 = $$;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'join\'']);
    }
    return $2;
  }

  OrderbyClause _parseOrderbyClause(bool $0, bool $1) {
    OrderbyClause $2;
    final $3 = _pos;
    final $4 = _c;
    OrderbyClause $6;
    _parse_orderby(false, false);
    if (_success) {
      final $10 = _parseOrderings(false, $1);
      if (_success) {
        final o = $10;
        OrderbyClause $$;
        $$ = OrderbyClause(o);
        $6 = $$;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'orderby\'']);
    }
    return $2;
  }

  List<Ordering> _parseOrderings(bool $0, bool $1) {
    List<Ordering> $2;
    final $3 = _pos;
    List<Ordering> $6;
    final $9 = _parseOrdering(false, $1);
    if (_success) {
      List<Ordering> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        Ordering $11;
        final $12 = _pos;
        final $13 = _c;
        Ordering $15;
        _parse_$Comma(true, false);
        if (_success) {
          final $19 = _parseOrdering(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\',\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      List<Ordering> $$;
      $$ = [h, ...t];
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  Ordering _parseOrdering(bool $0, bool $1) {
    Ordering $2;
    final $3 = _pos;
    Ordering $6;
    final $9 = _parseExpression(true, $1);
    if (_success) {
      final $10 = _parseOrderingDirection(false, $1);
      final $11 = $10;
      _success = true;
      final e = $9;
      final o = $11;
      Ordering $$;
      $$ = Ordering(e, o);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  OrderingDirection _parseOrderingDirection(bool $0, bool $1) {
    OrderingDirection $2;
    final $3 = _pos;
    for (;;) {
      OrderingDirection $6;
      _parse_ascending(false, $1);
      if (_success) {
        OrderingDirection $$;
        $$ = OrderingDirection.ascending;
        $6 = $$;
      }
      if (_success) {
        $2 = $6;
        break;
      }
      OrderingDirection $10;
      _parse_descending(false, $1);
      if (_success) {
        OrderingDirection $$;
        $$ = OrderingDirection.descending;
        $10 = $$;
      }
      if (_success) {
        $2 = $10;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'ascending\'', '\'descending\'']);
    }
    return $2;
  }

  SelectOrGroupClause _parseSelectOrGroupClause(bool $0, bool $1) {
    SelectOrGroupClause $2;
    final $3 = _pos;
    for (;;) {
      SelectOrGroupClause $6;
      final $9 = _parseSelectClause(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      SelectOrGroupClause $10;
      final $13 = _parseGroupClause(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'select\'', '\'group\'']);
    }
    return $2;
  }

  SelectClause _parseSelectClause(bool $0, bool $1) {
    SelectClause $2;
    final $3 = _pos;
    final $4 = _c;
    SelectClause $6;
    _parse_select(false, false);
    if (_success) {
      final $10 = _parseExpression(true, $1);
      if (_success) {
        final r = $10;
        SelectClause $$;
        $$ = SelectClause(r);
        $6 = $$;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'select\'']);
    }
    return $2;
  }

  GroupClause _parseGroupClause(bool $0, bool $1) {
    GroupClause $2;
    final $3 = _pos;
    final $4 = _c;
    GroupClause $6;
    _parse_group(false, false);
    if (_success) {
      final $10 = _parseExpression(false, $1);
      if (_success) {
        _parse_by(false, false);
        if (_success) {
          final $12 = _parseExpression(false, $1);
          if (_success) {
            final e = $10;
            final k = $12;
            GroupClause $$;
            $$ = GroupClause(e, k);
            $6 = $$;
          }
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'group\'']);
    }
    return $2;
  }

  QueryContinuation _parseQueryContinuation(bool $0, bool $1) {
    QueryContinuation $2;
    final $3 = _pos;
    final $4 = _c;
    QueryContinuation $6;
    _parse_into(true, false);
    if (_success) {
      final $10 = _parseIdentifier(true, $1);
      if (_success) {
        final $11 = _parseQueryBody(true, $1);
        if (_success) {
          final v = $10;
          final b = $11;
          QueryContinuation $$;
          $$ = QueryContinuation(v, b);
          $6 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'into\'']);
    }
    return $2;
  }

  Expression _parsePrimaryExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $9 = _parseLiteral(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      Expression $10;
      final $13 = _parseIdentifier(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      Expression $14;
      final $17 = _parseNewExpression(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      Expression $18;
      final $19 = _c;
      final $20 = _pos;
      _parse_$LeftParenthesis(false, false);
      if (_success) {
        final $22 = _parseExpression(false, $1);
        if (_success) {
          _parse_$RightParenthesis(false, false);
          if (_success) {
            final v = $22;
            Expression $$;
            $$ = ParenthesesExpression(v);
            $18 = $$;
          }
        }
        if (!_success) {
          _c = $19;
          _pos = $20;
        }
      }
      if (_success) {
        $2 = $18;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  IdentifierExpression _parseIdentifier(bool $0, bool $1) {
    IdentifierExpression $2;
    final $3 = _pos;
    IdentifierExpression $6;
    final $9 = _parse_identifier(false, $1);
    if (_success) {
      final v = $9;
      IdentifierExpression $$;
      $$ = IdentifierExpression(v);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'identifier\'']);
    }
    return $2;
  }

  Expression _parseLiteral(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    for (;;) {
      Expression $6;
      final $9 = _parseNullLiteral(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      Expression $10;
      final $13 = _parseStringLiteral(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      Expression $14;
      final $17 = _parseListLiteral(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      Expression $18;
      final $21 = _parseMapLiteral(false, $1);
      if (_success) {
        $18 = $21;
        $2 = $18;
        break;
      }
      Expression $22;
      final $25 = _parseBooleanLiteral(false, $1);
      if (_success) {
        $22 = $25;
        $2 = $22;
        break;
      }
      Expression $26;
      final $29 = _parseNumericLiteral(false, $1);
      if (_success) {
        $26 = $29;
        $2 = $26;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  Expression _parseNullLiteral(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    _parse_null(false, $1);
    if (_success) {
      Expression $$;
      $$ = NullLiteralExpression();
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'null\'']);
    }
    return $2;
  }

  Expression _parseStringLiteral(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parse_string(false, $1);
    if (_success) {
      final v = $9;
      Expression $$;
      $$ = StringLiteralExpression(v);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'string\'']);
    }
    return $2;
  }

  Expression _parseMapLiteral(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    Expression $6;
    final $9 = _parseTwoTypeArguments(false, $1);
    final $10 = $9;
    _parse_$LeftBrace(true, false);
    if (_success) {
      final $12 = _parseMapEntries(false, $1);
      final $13 = $12;
      _parse_$RightBrace(false, false);
      if (_success) {
        final a = $10;
        final e = $13;
        Expression $$;
        $$ = MapLiteralExpression(e, a);
        $6 = $$;
      }
    }
    if (!_success) {
      _c = $4;
      _pos = $3;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'{\'']);
    }
    return $2;
  }

  List<MapEntryLiteralExpression> _parseMapEntries(bool $0, bool $1) {
    List<MapEntryLiteralExpression> $2;
    final $3 = _pos;
    List<MapEntryLiteralExpression> $6;
    final $9 = _parseMapEntry(false, $1);
    if (_success) {
      List<MapEntryLiteralExpression> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        MapEntryLiteralExpression $11;
        final $12 = _pos;
        final $13 = _c;
        MapEntryLiteralExpression $15;
        _parse_$Comma(true, false);
        if (_success) {
          final $19 = _parseMapEntry(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\',\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      List<MapEntryLiteralExpression> $$;
      $$ = [h, ...t];
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  MapEntryLiteralExpression _parseMapEntry(bool $0, bool $1) {
    MapEntryLiteralExpression $2;
    final $3 = _pos;
    final $4 = _c;
    MapEntryLiteralExpression $6;
    final $9 = _parseExpression(false, $1);
    if (_success) {
      _parse_$Colon(true, false);
      if (_success) {
        final $11 = _parseExpression(false, $1);
        if (_success) {
          final k = $9;
          final v = $11;
          MapEntryLiteralExpression $$;
          $$ = MapEntryLiteralExpression(k, v);
          $6 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  Expression _parseListLiteral(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    Expression $6;
    final $9 = _parseOneTypeArgument(false, $1);
    final $10 = $9;
    _parse_$LeftSquareBracket(true, false);
    if (_success) {
      final $12 = _parseElements(false, $1);
      final $13 = $12;
      _parse_$RightSquareBracket(false, false);
      if (_success) {
        final a = $10;
        final e = $13;
        Expression $$;
        $$ = ListLiteralExpression(e, a);
        $6 = $$;
      }
    }
    if (!_success) {
      _c = $4;
      _pos = $3;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'[\'']);
    }
    return $2;
  }

  List<Expression> _parseElements(bool $0, bool $1) {
    List<Expression> $2;
    final $3 = _pos;
    List<Expression> $6;
    final $9 = _parseExpression(false, $1);
    if (_success) {
      List<Expression> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        Expression $11;
        final $12 = _pos;
        final $13 = _c;
        Expression $15;
        _parse_$Comma(true, false);
        if (_success) {
          final $19 = _parseExpression(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\',\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      List<Expression> $$;
      $$ = [h, ...t];
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  Expression _parseBooleanLiteral(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    bool $9;
    for (;;) {
      bool $13;
      final $16 = _parse_true(false, $1);
      if (_success) {
        $13 = $16;
        $9 = $13;
        break;
      }
      bool $17;
      final $20 = _parse_false(false, $1);
      if (_success) {
        $17 = $20;
        $9 = $17;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'true\'', '\'false\'']);
    }
    if (_success) {
      final v = $9;
      Expression $$;
      $$ = BooleanLiteralExpression(v);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'true\'', '\'false\'']);
    }
    return $2;
  }

  Expression _parseNumericLiteral(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    num $9;
    for (;;) {
      num $13;
      final $16 = _parse_number(false, $1);
      if (_success) {
        $13 = $16;
        $9 = $13;
        break;
      }
      num $17;
      final $20 = _parse_hex_number(false, $1);
      if (_success) {
        $17 = $20;
        $9 = $17;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'number\'', '\'hex number\'']);
    }
    if (_success) {
      final v = $9;
      Expression $$;
      $$ = NumericLiteralExpression(v);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'number\'', '\'hex number\'']);
    }
    return $2;
  }

  Expression _parseNewExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    Expression $6;
    _parse_new(false, $1);
    if (_success) {
      _parse_$LeftBrace(true, false);
      if (_success) {
        _parse_$RightBrace(false, false);
        if (_success) {
          Expression $$;
          throw UnimplementedError();
          $6 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'new\'']);
    }
    return $2;
  }

  Expression _parseAssignableExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parsePrimaryExpression(false, $1);
      if (_success) {
        List $10;
        if ($1) {
          $10 = [];
        }
        var $11 = false;
        for (;;) {
          final $12 = _parseSelector(false, $1);
          if (!_success) {
            _success = $11;
            if (!_success) {
              $10 = null;
            }
            break;
          }
          if ($1) {
            $10.add($12);
          }
          $11 = true;
        }
        if (_success) {
          final e = $9;
          final s = $10;
          Expression $$;
          $$ = _buildAssignable(e, s);
          $6 = $$;
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $13;
      final $16 = _parseIdentifier(false, $1);
      if (_success) {
        $13 = $16;
        $2 = $13;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  List _parseAssignableSelector(bool $0, bool $1) {
    List $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      List $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parse_$LeftSquareBracket(true, $1);
      if (_success) {
        final $10 = _parseExpression(true, $1);
        if (_success) {
          _parse_$RightSquareBracket(false, false);
          if (_success) {
            if (_success) {
              $6 = [$9, $10];
            }
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      List $12;
      final $13 = _c;
      final $14 = _pos;
      final $15 = _parse_$Period(false, $1);
      if (_success) {
        final $16 = _parseIdentifier(true, $1);
        if (_success) {
          if (_success) {
            $12 = [$15, $16];
          }
        }
        if (!_success) {
          _c = $13;
          _pos = $14;
        }
      }
      if (_success) {
        $2 = $12;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'[\'', '\'.\'']);
    }
    return $2;
  }

  Expression _parseArguments(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    Expression $6;
    _parse_$LeftParenthesis(true, false);
    if (_success) {
      final $10 = _parseArgumentList(false, $1);
      final $11 = $10;
      _parse_$RightParenthesis(false, false);
      if (_success) {
        final v = $11;
        Expression $$;
        $$ = ArgumentsExpression(v);
        $6 = $$;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'(\'']);
    }
    return $2;
  }

  List<Expression> _parseArgumentList(bool $0, bool $1) {
    List<Expression> $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      List<Expression> $6;
      final $9 = _parseNamedArgument(false, $1);
      if (_success) {
        List<LabeledExpression> $10;
        if ($1) {
          $10 = [];
        }
        for (;;) {
          LabeledExpression $11;
          final $12 = _pos;
          final $13 = _c;
          LabeledExpression $15;
          _parse_$Comma(true, false);
          if (_success) {
            final $19 = _parseNamedArgument(false, $1);
            if (_success) {
              $15 = $19;
            } else {
              _c = $13;
              _pos = $12;
            }
          }
          $11 = $15;
          if (!_success && _error == $12) {
            _fail(const ['\',\'']);
          }
          if (!_success) {
            _success = true;
            break;
          }
          if ($1) {
            $10.add($11);
          }
        }
        final h = $9;
        final t = $10;
        List<Expression> $$;
        $$ = [h, ...t];
        $6 = $$;
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      List<Expression> $20;
      final $23 = _parseExpressionList(false, $1);
      if (_success) {
        List<LabeledExpression> $24;
        if ($1) {
          $24 = [];
        }
        for (;;) {
          LabeledExpression $25;
          final $26 = _pos;
          final $27 = _c;
          LabeledExpression $29;
          _parse_$Comma(true, false);
          if (_success) {
            final $33 = _parseNamedArgument(false, $1);
            if (_success) {
              $29 = $33;
            } else {
              _c = $27;
              _pos = $26;
            }
          }
          $25 = $29;
          if (!_success && _error == $26) {
            _fail(const ['\',\'']);
          }
          if (!_success) {
            _success = true;
            break;
          }
          if ($1) {
            $24.add($25);
          }
        }
        final h = $23;
        final t = $24;
        List<Expression> $$;
        $$ = [...h, ...t];
        $20 = $$;
      }
      if (_success) {
        $2 = $20;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'identifier\'',
        '\'(\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  LabeledExpression _parseNamedArgument(bool $0, bool $1) {
    LabeledExpression $2;
    final $3 = _pos;
    LabeledExpression $6;
    final $9 = _parseLabeledExpression(false, $1);
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'identifier\'']);
    }
    return $2;
  }

  LabeledExpression _parseLabeledExpression(bool $0, bool $1) {
    LabeledExpression $2;
    final $3 = _pos;
    final $4 = _c;
    LabeledExpression $6;
    final $9 = _parse_identifier(true, $1);
    if (_success) {
      _parse_$Colon(true, false);
      if (_success) {
        final $11 = _parseExpression(true, $1);
        if (_success) {
          final l = $9;
          final e = $11;
          LabeledExpression $$;
          $$ = LabeledExpression(l, e);
          $6 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'identifier\'']);
    }
    return $2;
  }

  List<Expression> _parseExpressionList(bool $0, bool $1) {
    List<Expression> $2;
    final $3 = _pos;
    List<Expression> $6;
    final $9 = _parseExpression(false, $1);
    if (_success) {
      List<Expression> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        Expression $11;
        final $12 = _pos;
        final $13 = _c;
        Expression $15;
        _parse_$Comma(true, false);
        if (_success) {
          final $19 = _parseExpression(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\',\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      List<Expression> $$;
      $$ = [h, ...t];
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  Expression _parsePostfixExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseAssignableExpression(true, $1);
      if (_success) {
        final $10 = _parseIncrementOperator(true, $1);
        if (_success) {
          final e = $9;
          final o = $10;
          Expression $$;
          $$ = _postUnary(o, e);
          $6 = $$;
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $11;
      final $14 = _parseAssignableExpression(true, $1);
      if (_success) {
        List $15;
        if ($1) {
          $15 = [];
        }
        for (;;) {
          final $16 = _parseSelector(false, $1);
          if (!_success) {
            _success = true;
            break;
          }
          if ($1) {
            $15.add($16);
          }
        }
        final e = $14;
        final s = $15;
        Expression $$;
        $$ = _buildAssignable(e, s);
        $11 = $$;
      }
      if (_success) {
        $2 = $11;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $17;
      final $20 = _parsePrimaryExpression(true, $1);
      if (_success) {
        $17 = $20;
        $2 = $17;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  dynamic _parseSelector(bool $0, bool $1) {
    dynamic $2;
    final $3 = _pos;
    for (;;) {
      List $6;
      final $9 = _parseAssignableSelector(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      Expression $10;
      final $13 = _parseArguments(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'[\'', '\'.\'', '\'(\'']);
    }
    return $2;
  }

  String _parseIncrementOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$PlusSign$PlusSign(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse_$MinusSign$MinusSign(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'++\'', '\'--\'']);
    }
    return $2;
  }

  Expression _parseUnaryExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parsePrefixOperator(false, $1);
      if (_success) {
        final $10 = _parseUnaryExpression(true, $1);
        if (_success) {
          final o = $9;
          final e = $10;
          Expression $$;
          $$ = _unary(o, e);
          $6 = $$;
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $11;
      final $14 = _parsePostfixExpression(false, $1);
      if (_success) {
        $11 = $14;
        $2 = $11;
        break;
      }
      Expression $15;
      final $16 = _c;
      final $17 = _pos;
      final $18 = _parseIncrementOperator(false, $1);
      if (_success) {
        final $19 = _parseAssignableExpression(false, $1);
        if (_success) {
          final o = $18;
          final e = $19;
          Expression $$;
          $$ = _unary(o, e);
          $15 = $$;
        }
        if (!_success) {
          _c = $16;
          _pos = $17;
        }
      }
      if (_success) {
        $2 = $15;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parsePrefixOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$MinusSign(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse_$TildeAccent(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      String $14;
      final $17 = _parse_$ExclamationMark(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'-\'', '\'~\'', '\'!\'']);
    }
    return $2;
  }

  Expression _parseMultiplicativeExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseUnaryExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseMultiplicativeOperator(false, $1);
        if (_success) {
          final $19 = _parseUnaryExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'*\'', '\'/\'', '\'%\'', '\'~/\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseMultiplicativeOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$Asterisk(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse_$Slash(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      String $14;
      final $17 = _parse_$PercentSign(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      String $18;
      final $21 = _parse_$TildeAccent$Slash(false, $1);
      if (_success) {
        $18 = $21;
        $2 = $18;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'*\'', '\'/\'', '\'%\'', '\'~/\'']);
    }
    return $2;
  }

  Expression _parseAdditiveExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseMultiplicativeExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseAdditiveOperator(false, $1);
        if (_success) {
          final $19 = _parseMultiplicativeExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'+\'', '\'-\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseAdditiveOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$PlusSign(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse_$MinusSign(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'+\'', '\'-\'']);
    }
    return $2;
  }

  Expression _parseShiftExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseAdditiveExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseShiftOperator(false, $1);
        if (_success) {
          final $19 = _parseAdditiveExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'<<\'', '\'>>>\'', '\'>>\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseShiftOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$LessThanSign$LessThanSign(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse$Terminal138(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      String $14;
      final $17 = _parse$Terminal139(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'<<\'', '\'>>>\'', '\'>>\'']);
    }
    return $2;
  }

  Expression _parseRelationalExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseShiftExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseRelationalOperator(false, $1);
        if (_success) {
          final $19 = _parseShiftExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'<=\'', '\'>=\'', '\'<\'', '\'>\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseRelationalOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$LessThanSign$EqualSign(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse_$GreaterThanSign$EqualSign(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      String $14;
      final $17 = _parse_$LessThanSign(true, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      String $18;
      final $21 = _parse_$GreaterThanSign(false, $1);
      if (_success) {
        $18 = $21;
        $2 = $18;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'<=\'', '\'>=\'', '\'<\'', '\'>\'']);
    }
    return $2;
  }

  Expression _parseEqualityExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseRelationalExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseEqualityOperator(false, $1);
        if (_success) {
          final $19 = _parseRelationalExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'==\'', '\'!=\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseEqualityOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$EqualSign$EqualSign(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse_$ExclamationMark$EqualSign(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'==\'', '\'!=\'']);
    }
    return $2;
  }

  Expression _parseBitwiseAndExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseEqualityExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseBitwiseAndOperator(false, $1);
        if (_success) {
          final $19 = _parseEqualityExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'&\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseBitwiseAndOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $6;
    final $9 = _parse_$Ampersand(false, $1);
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'&\'']);
    }
    return $2;
  }

  Expression _parseBitwiseXorExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseBitwiseAndExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseBitwiseXorOperator(false, $1);
        if (_success) {
          final $19 = _parseBitwiseAndExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'^\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseBitwiseXorOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $6;
    final $9 = _parse_$SpacingCircumflexAccent(false, $1);
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'^\'']);
    }
    return $2;
  }

  Expression _parseBitwiseOrExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseBitwiseXorExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseBitwiseOrOperator(false, $1);
        if (_success) {
          final $19 = _parseBitwiseXorExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'|\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseBitwiseOrOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $6;
    final $9 = _parse_$VerticalBar(false, $1);
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'|\'']);
    }
    return $2;
  }

  Expression _parseLogicalAndExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseBitwiseOrExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseLogicalAndOperator(false, $1);
        if (_success) {
          final $19 = _parseBitwiseOrExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'&&\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseLogicalAndOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $6;
    final $9 = _parse_$Ampersand$Ampersand(false, $1);
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'&&\'']);
    }
    return $2;
  }

  Expression _parseLogicalOrExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseLogicalAndExpression(false, $1);
    if (_success) {
      List<List> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        List $11;
        final $12 = _pos;
        final $13 = _c;
        List $15;
        final $18 = _parseLogicalOrOperator(false, $1);
        if (_success) {
          final $19 = _parseLogicalAndExpression(false, $1);
          if (_success) {
            if (_success) {
              $15 = [$18, $19];
            }
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'||\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      Expression $$;
      $$ = _buildBinary(h, t);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseLogicalOrOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $6;
    final $9 = _parse_$VerticalBar$VerticalBar(false, $1);
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'||\'']);
    }
    return $2;
  }

  Expression _parseConditionalExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseLogicalOrExpression(true, $1);
      if (_success) {
        _parse_$QuestionMark(false, false);
        if (_success) {
          final $11 = _parseAssignmentExpression(false, $1);
          if (_success) {
            _parse_$Colon(true, false);
            if (_success) {
              final $13 = _parseAssignmentExpression(false, $1);
              if (_success) {
                final e = $9;
                final t = $11;
                final f = $13;
                Expression $$;
                $$ = ConditionalExpression(e, t, f);
                $6 = $$;
              }
            }
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $14;
      final $17 = _parseLogicalOrExpression(true, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  Expression _parseAssignmentExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseUnaryExpression(true, $1);
      if (_success) {
        final $10 = _parseAssignmentOperator(true, $1);
        if (_success) {
          final $11 = _parseAssignmentExpression(false, $1);
          if (_success) {
            final l = $9;
            final o = $10;
            final r = $11;
            Expression $$;
            $$ = Expression.binary(o, l, r);
            $6 = $$;
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $12;
      final $15 = _parseConditionalExpression(false, $1);
      if (_success) {
        $12 = $15;
        $2 = $12;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'new\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  String _parseAssignmentOperator(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    for (;;) {
      String $6;
      final $9 = _parse_$EqualSign(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      String $10;
      final $13 = _parse_$Asterisk$EqualSign(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      String $14;
      final $17 = _parse_$Slash$EqualSign(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      String $18;
      final $21 = _parse_$TildeAccent$Slash$EqualSign(false, $1);
      if (_success) {
        $18 = $21;
        $2 = $18;
        break;
      }
      String $22;
      final $25 = _parse_$PercentSign$EqualSign(false, $1);
      if (_success) {
        $22 = $25;
        $2 = $22;
        break;
      }
      String $26;
      final $29 = _parse_$PlusSign$EqualSign(false, $1);
      if (_success) {
        $26 = $29;
        $2 = $26;
        break;
      }
      String $30;
      final $33 = _parse_$MinusSign$EqualSign(false, $1);
      if (_success) {
        $30 = $33;
        $2 = $30;
        break;
      }
      String $34;
      final $37 = _parse$Terminal119(false, $1);
      if (_success) {
        $34 = $37;
        $2 = $34;
        break;
      }
      String $38;
      final $41 = _parse$Terminal121(false, $1);
      if (_success) {
        $38 = $41;
        $2 = $38;
        break;
      }
      String $42;
      final $45 = _parse$Terminal120(false, $1);
      if (_success) {
        $42 = $45;
        $2 = $42;
        break;
      }
      String $46;
      final $49 = _parse_$Ampersand$EqualSign(false, $1);
      if (_success) {
        $46 = $49;
        $2 = $46;
        break;
      }
      String $50;
      final $53 = _parse$Terminal123(false, $1);
      if (_success) {
        $50 = $53;
        $2 = $50;
        break;
      }
      String $54;
      final $57 = _parse_$VerticalBar$EqualSign(false, $1);
      if (_success) {
        $54 = $57;
        $2 = $54;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'=\'',
        '\'*=\'',
        '\'/=\'',
        '\'~/=\'',
        '\'%=\'',
        '\'+=\'',
        '\'-=\'',
        '\'<<=\'',
        '\'>>=\'',
        '\'>>>=\'',
        '\'&=\'',
        '\'^=\'',
        '\'|=\''
      ]);
    }
    return $2;
  }

  Expression _parseExpression(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseAssignableExpression(false, $1);
      if (_success) {
        final $10 = _parseAssignmentOperator(false, $1);
        if (_success) {
          final $11 = _parseExpression(true, $1);
          if (_success) {
            final l = $9;
            final o = $10;
            final r = $11;
            Expression $$;
            $$ = Expression.binary(o, l, r);
            $6 = $$;
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $12;
      final $15 = _parseConditionalExpression(false, $1);
      if (_success) {
        $12 = $15;
        $2 = $12;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'(\'',
        '\'identifier\'',
        '\'++\'',
        '\'--\'',
        '\'new\'',
        '\'-\'',
        '\'~\'',
        '\'!\'',
        '\'null\'',
        '\'string\'',
        '\'[\'',
        '\'{\'',
        '\'true\'',
        '\'false\'',
        '\'number\'',
        '\'hex number\''
      ]);
    }
    return $2;
  }

  ParameterExpression _parseParameter(bool $0, bool $1) {
    ParameterExpression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      ParameterExpression $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseType(false, $1);
      if (_success) {
        final $10 = _parseIdentifier(false, $1);
        if (_success) {
          final t = $9;
          final i = $10;
          ParameterExpression $$;
          $$ = ParameterExpression(i, t);
          $6 = $$;
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      ParameterExpression $11;
      final $14 = _parseIdentifier(false, $1);
      if (_success) {
        final i = $14;
        ParameterExpression $$;
        $$ = ParameterExpression(i, null);
        $11 = $$;
      }
      if (_success) {
        $2 = $11;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'identifier\'']);
    }
    return $2;
  }

  TypeExpression _parseType(bool $0, bool $1) {
    TypeExpression $2;
    final $3 = _pos;
    TypeExpression $6;
    final $9 = _parseIdentifier(false, $1);
    if (_success) {
      final $10 = _parseTypeArguments(false, $1);
      final $11 = $10;
      _success = true;
      final i = $9;
      final a = $11;
      TypeExpression $$;
      $$ = TypeExpression(i, a);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'identifier\'']);
    }
    return $2;
  }

  TypeArgumentsExpression _parseTypeArguments(bool $0, bool $1) {
    TypeArgumentsExpression $2;
    final $3 = _pos;
    final $4 = _c;
    TypeArgumentsExpression $6;
    _parse_$LessThanSign(true, false);
    if (_success) {
      final $10 = _parseTypeArgumentList(false, $1);
      if (_success) {
        _parse_$GreaterThanSign(false, false);
        if (_success) {
          final v = $10;
          TypeArgumentsExpression $$;
          $$ = TypeArgumentsExpression(v);
          $6 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'<\'']);
    }
    return $2;
  }

  List<TypeExpression> _parseTypeArgumentList(bool $0, bool $1) {
    List<TypeExpression> $2;
    final $3 = _pos;
    List<TypeExpression> $6;
    final $9 = _parseType(false, $1);
    if (_success) {
      List<TypeExpression> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        TypeExpression $11;
        final $12 = _pos;
        final $13 = _c;
        TypeExpression $15;
        _parse_$Comma(true, false);
        if (_success) {
          final $19 = _parseType(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\',\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final h = $9;
      final t = $10;
      List<TypeExpression> $$;
      $$ = [h, ...t];
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'identifier\'']);
    }
    return $2;
  }

  TypeArgumentsExpression _parseOneTypeArgument(bool $0, bool $1) {
    TypeArgumentsExpression $2;
    final $3 = _pos;
    final $4 = _c;
    TypeArgumentsExpression $6;
    _parse_$LessThanSign(true, false);
    if (_success) {
      final $10 = _parseType(true, $1);
      if (_success) {
        _parse_$GreaterThanSign(false, false);
        if (_success) {
          final v = $10;
          TypeArgumentsExpression $$;
          $$ = TypeArgumentsExpression([v]);
          $6 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'<\'']);
    }
    return $2;
  }

  TypeArgumentsExpression _parseTwoTypeArguments(bool $0, bool $1) {
    TypeArgumentsExpression $2;
    final $3 = _pos;
    final $4 = _c;
    TypeArgumentsExpression $6;
    _parse_$LessThanSign(true, false);
    if (_success) {
      final $10 = _parseType(false, $1);
      if (_success) {
        _parse_$Comma(true, false);
        if (_success) {
          final $12 = _parseType(false, $1);
          if (_success) {
            _parse_$GreaterThanSign(false, false);
            if (_success) {
              final f = $10;
              final n = $12;
              TypeArgumentsExpression $$;
              $$ = TypeArgumentsExpression([f, n]);
              $6 = $$;
            }
          }
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'<\'']);
    }
    return $2;
  }

  List<int> _parse_leading_spaces(bool $0, bool $1) {
    List<int> $2;
    $2 = _parse$$whitespace(false, false);
    if (!_success && _error <= _failure) {
      _fail(const ['\'leading spaces\'']);
    }
    return $2;
  }

  dynamic _parse_end_of_file(bool $0, bool $1) {
    dynamic $2;
    final $3 = _pos;
    final $4 = _c;
    dynamic $7;
    final $12 = _error;
    final $13 = _expected;
    final $14 = _failure;
    final $15 = $1;
    $1 = false;
    if (_c >= 0 && _c <= 1114111) {
      _success = true;
      _c = _input[_pos += _c <= 65535 ? 1 : 2];
    } else {
      _success = false;
      _failure = _pos;
    }
    _success = !_success;
    _c = $4;
    _pos = $3;
    _error = $12;
    _expected = $13;
    _failure = $14;
    $1 = $15;
    var $17;
    if (_success) {
      $7 = $17;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'end of file\'']);
    }
    return $2;
  }

  String _parse_from(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('from');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'from\'']);
    }
    return $2;
  }

  String _parse_identifier(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $7;
    String $10;
    final $12 = $1;
    $1 = false;
    final $14 = _pos;
    final $15 = _c;
    final $23 = _error;
    final $24 = _expected;
    final $25 = _failure;
    final $26 = $1;
    $1 = false;
    _parse$$keywords(false, false);
    _success = !_success;
    _c = $15;
    _pos = $14;
    _error = $23;
    _expected = $24;
    _failure = $25;
    $1 = $26;
    if (_success) {
      _parse$$identStart(false, false);
      if (_success) {
        for (;;) {
          _parse$$identCont(false, false);
          if (!_success) {
            _success = true;
            break;
          }
        }
      }
      if (!_success) {
        _c = $15;
        _pos = $14;
      }
    }
    if (_success) {
      $10 = _text.substring($3, _pos);
    }
    $1 = $12;
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'identifier\'']);
    }
    return $2;
  }

  String _parse_in(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('in');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'in\'']);
    }
    return $2;
  }

  String _parse_let(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('let');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'let\'']);
    }
    return $2;
  }

  String _parse_$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'=\'']);
    }
    return $2;
  }

  String _parse_where(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('where');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'where\'']);
    }
    return $2;
  }

  String _parse_join(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('join');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'join\'']);
    }
    return $2;
  }

  String _parse_on(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('on');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'on\'']);
    }
    return $2;
  }

  String _parse_equals(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('equals');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'equals\'']);
    }
    return $2;
  }

  String _parse_into(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('into');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'into\'']);
    }
    return $2;
  }

  String _parse_orderby(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('orderby');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'orderby\'']);
    }
    return $2;
  }

  String _parse_$Comma(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString(',');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\',\'']);
    }
    return $2;
  }

  String _parse_ascending(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('ascending');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'ascending\'']);
    }
    return $2;
  }

  String _parse_descending(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('descending');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'descending\'']);
    }
    return $2;
  }

  String _parse_select(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('select');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'select\'']);
    }
    return $2;
  }

  String _parse_group(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('group');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'group\'']);
    }
    return $2;
  }

  String _parse_by(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('by');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'by\'']);
    }
    return $2;
  }

  String _parse_new(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('new');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'new\'']);
    }
    return $2;
  }

  String _parse_string(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    final $4 = _c;
    String $7;
    _matchString('\"');
    if (_success) {
      List<int> $11;
      if ($1) {
        $11 = [];
      }
      for (;;) {
        final $12 = _parse$$char(false, $1);
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $11.add($12);
        }
      }
      _matchString('\"');
      if (_success) {
        _parse$$whitespace(false, false);
        final c = $11;
        String $$;
        $$ = String.fromCharCodes(c);
        $7 = $$;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'string\'']);
    }
    return $2;
  }

  num _parse_number(bool $0, bool $1) {
    num $2;
    final $3 = _pos;
    num $7;
    String $10;
    final $12 = $1;
    $1 = false;
    final $14 = _pos;
    final $15 = _c;
    _matchChar(45);
    var $27 = _pos;
    for (;;) {
      _matchChar(48);
      if ($27 < _failure) {
        $27 = _failure;
      }
      if (_success) {
        break;
      }
      const $35 = [49, 57];
      _matchRanges($35);
      if (_success) {
        for (;;) {
          const $38 = [48, 57];
          _matchRanges($38);
          if (!_success) {
            _success = true;
            break;
          }
        }
      }
      if ($27 < _failure) {
        $27 = _failure;
      }
      if (_success) {
        break;
      }
      _c = $15;
      _pos = $14;
      _failure = $27;
      break;
    }
    if (_success) {
      final $41 = _pos;
      final $42 = _c;
      _matchChar(46);
      if (_success) {
        var $50 = false;
        for (;;) {
          const $51 = [48, 57];
          _matchRanges($51);
          if (!_success) {
            _success = $50;
            break;
          }
          $50 = true;
        }
        if (!_success) {
          _c = $42;
          _pos = $41;
        }
      }
      final $55 = _pos;
      final $56 = _c;
      const $62 = [69, 69, 101, 101];
      _matchRanges($62);
      if (_success) {
        const $64 = [43, 43, 45, 45];
        _matchRanges($64);
        var $68 = false;
        for (;;) {
          const $69 = [48, 57];
          _matchRanges($69);
          if (!_success) {
            _success = $68;
            break;
          }
          $68 = true;
        }
        if (!_success) {
          _c = $56;
          _pos = $55;
        }
      }
      _success = true;
    }
    if (_success) {
      $10 = _text.substring($3, _pos);
    }
    $1 = $12;
    if (_success) {
      _parse$$whitespace(false, false);
      final n = $10;
      num $$;
      $$ = num.parse(n);
      $7 = $$;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'number\'']);
    }
    return $2;
  }

  num _parse_hex_number(bool $0, bool $1) {
    num $2;
    final $3 = _pos;
    num $7;
    String $10;
    final $12 = $1;
    $1 = false;
    final $14 = _pos;
    final $15 = _c;
    _matchString('0');
    if (_success) {
      const $22 = [88, 88, 120, 120];
      _matchRanges($22);
      if (_success) {
        var $25 = false;
        for (;;) {
          _parse$$hexdig(false, false);
          if (!_success) {
            _success = $25;
            break;
          }
          $25 = true;
        }
      }
      if (!_success) {
        _c = $15;
        _pos = $14;
      }
    }
    if (_success) {
      $10 = _text.substring($3, _pos);
    }
    $1 = $12;
    if (_success) {
      final v = $10;
      num $$;
      $$ = num.parse(v);
      $7 = $$;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'hex number\'']);
    }
    return $2;
  }

  bool _parse_true(bool $0, bool $1) {
    bool $2;
    bool $7;
    _matchString('true');
    if (_success) {
      _parse$$whitespace(false, false);
      bool $$;
      $$ = true;
      $7 = $$;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'true\'']);
    }
    return $2;
  }

  bool _parse_false(bool $0, bool $1) {
    bool $2;
    bool $7;
    _matchString('false');
    if (_success) {
      _parse$$whitespace(false, false);
      bool $$;
      $$ = false;
      $7 = $$;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'false\'']);
    }
    return $2;
  }

  dynamic _parse_null(bool $0, bool $1) {
    dynamic $2;
    dynamic $7;
    _matchString('null');
    if (_success) {
      _parse$$whitespace(false, false);
      dynamic $$;
      $$ = null;
      $7 = $$;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'null\'']);
    }
    return $2;
  }

  String _parse_$PlusSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('+');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'+\'']);
    }
    return $2;
  }

  String _parse_$MinusSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('-');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'-\'']);
    }
    return $2;
  }

  String _parse_$Slash(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('/');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'/\'']);
    }
    return $2;
  }

  String _parse_$Asterisk(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('*');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'*\'']);
    }
    return $2;
  }

  String _parse_$TildeAccent(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('~');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'~\'']);
    }
    return $2;
  }

  String _parse_$ExclamationMark(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('!');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'!\'']);
    }
    return $2;
  }

  String _parse_$PlusSign$PlusSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('++');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'++\'']);
    }
    return $2;
  }

  String _parse_$MinusSign$MinusSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('--');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'--\'']);
    }
    return $2;
  }

  String _parse_$LeftParenthesis(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('(');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'(\'']);
    }
    return $2;
  }

  String _parse_$RightParenthesis(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString(')');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\')\'']);
    }
    return $2;
  }

  String _parse_$LeftBrace(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('{');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'{\'']);
    }
    return $2;
  }

  String _parse_$RightBrace(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('}');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'}\'']);
    }
    return $2;
  }

  String _parse_$LeftSquareBracket(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('[');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'[\'']);
    }
    return $2;
  }

  String _parse_$RightSquareBracket(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString(']');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\']\'']);
    }
    return $2;
  }

  String _parse_$Colon(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString(':');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\':\'']);
    }
    return $2;
  }

  String _parse_$Asterisk$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('*=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'*=\'']);
    }
    return $2;
  }

  String _parse_$Slash$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('/=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'/=\'']);
    }
    return $2;
  }

  String _parse_$TildeAccent$Slash$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('~/=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'~/=\'']);
    }
    return $2;
  }

  String _parse_$PercentSign$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('%=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'%=\'']);
    }
    return $2;
  }

  String _parse_$PlusSign$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('+=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'+=\'']);
    }
    return $2;
  }

  String _parse_$MinusSign$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('-=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'-=\'']);
    }
    return $2;
  }

  String _parse$Terminal119(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('<<=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'<<=\'']);
    }
    return $2;
  }

  String _parse$Terminal120(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('>>>=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>>>=\'']);
    }
    return $2;
  }

  String _parse$Terminal121(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('>>=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>>=\'']);
    }
    return $2;
  }

  String _parse_$Ampersand$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('&=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'&=\'']);
    }
    return $2;
  }

  String _parse$Terminal123(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('^=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'^=\'']);
    }
    return $2;
  }

  String _parse_$VerticalBar$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('|=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'|=\'']);
    }
    return $2;
  }

  String _parse_$QuestionMark(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('?');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'?\'']);
    }
    return $2;
  }

  String _parse_$VerticalBar$VerticalBar(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('||');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'||\'']);
    }
    return $2;
  }

  String _parse_$Ampersand$Ampersand(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('&&');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'&&\'']);
    }
    return $2;
  }

  String _parse_$EqualSign$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('==');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'==\'']);
    }
    return $2;
  }

  String _parse_$ExclamationMark$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('!=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'!=\'']);
    }
    return $2;
  }

  String _parse_$GreaterThanSign$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('>=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>=\'']);
    }
    return $2;
  }

  String _parse_$GreaterThanSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('>');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>\'']);
    }
    return $2;
  }

  String _parse_$LessThanSign$EqualSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('<=');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'<=\'']);
    }
    return $2;
  }

  String _parse_$LessThanSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('<');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'<\'']);
    }
    return $2;
  }

  String _parse_$VerticalBar(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('|');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'|\'']);
    }
    return $2;
  }

  String _parse_$SpacingCircumflexAccent(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('^');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'^\'']);
    }
    return $2;
  }

  String _parse_$Ampersand(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('&');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'&\'']);
    }
    return $2;
  }

  String _parse_$LessThanSign$LessThanSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('<<');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'<<\'']);
    }
    return $2;
  }

  String _parse$Terminal138(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('>>>');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>>>\'']);
    }
    return $2;
  }

  String _parse$Terminal139(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('>>');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>>\'']);
    }
    return $2;
  }

  String _parse_$PercentSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('%');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'%\'']);
    }
    return $2;
  }

  String _parse_$TildeAccent$Slash(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('~/');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'~/\'']);
    }
    return $2;
  }

  String _parse_$Period(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('.');
    if (_success) {
      _parse$$whitespace(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'.\'']);
    }
    return $2;
  }

  List<int> _parse$$whitespace(bool $0, bool $1) {
    List<int> $2;
    for (;;) {
      const $10 = [9, 10, 13, 13, 32, 32];
      _matchRanges($10);
      if (!_success) {
        _success = true;
        break;
      }
    }
    return $2;
  }

  int _parse$$identStart(bool $0, bool $1) {
    int $2;
    int $6;
    const $9 = [65, 90, 97, 122];
    final $10 = _matchRanges($9);
    if (_success) {
      $6 = $10;
    }
    $2 = $6;
    return $2;
  }

  int _parse$$identCont(bool $0, bool $1) {
    int $2;
    int $6;
    const $9 = [48, 57, 65, 90, 95, 95, 97, 122];
    final $10 = _matchRanges($9);
    if (_success) {
      $6 = $10;
    }
    $2 = $6;
    return $2;
  }

  String _parse$$keywords(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    final $4 = _c;
    String $6;
    String $9;
    for (;;) {
      String $13;
      final $16 = _matchString('Function');
      if (_success) {
        $13 = $16;
        $9 = $13;
        break;
      }
      String $17;
      final $20 = _matchString('abstract');
      if (_success) {
        $17 = $20;
        $9 = $17;
        break;
      }
      String $21;
      final $24 = _matchString('as');
      if (_success) {
        $21 = $24;
        $9 = $21;
        break;
      }
      String $25;
      final $28 = _matchString('ascending');
      if (_success) {
        $25 = $28;
        $9 = $25;
        break;
      }
      String $29;
      final $32 = _matchString('assert');
      if (_success) {
        $29 = $32;
        $9 = $29;
        break;
      }
      String $33;
      final $36 = _matchString('async');
      if (_success) {
        $33 = $36;
        $9 = $33;
        break;
      }
      String $37;
      final $40 = _matchString('await');
      if (_success) {
        $37 = $40;
        $9 = $37;
        break;
      }
      String $41;
      final $44 = _matchString('break');
      if (_success) {
        $41 = $44;
        $9 = $41;
        break;
      }
      String $45;
      final $48 = _matchString('by');
      if (_success) {
        $45 = $48;
        $9 = $45;
        break;
      }
      String $49;
      final $52 = _matchString('case');
      if (_success) {
        $49 = $52;
        $9 = $49;
        break;
      }
      String $53;
      final $56 = _matchString('catch');
      if (_success) {
        $53 = $56;
        $9 = $53;
        break;
      }
      String $57;
      final $60 = _matchString('class');
      if (_success) {
        $57 = $60;
        $9 = $57;
        break;
      }
      String $61;
      final $64 = _matchString('const');
      if (_success) {
        $61 = $64;
        $9 = $61;
        break;
      }
      String $65;
      final $68 = _matchString('continue');
      if (_success) {
        $65 = $68;
        $9 = $65;
        break;
      }
      String $69;
      final $72 = _matchString('covariant');
      if (_success) {
        $69 = $72;
        $9 = $69;
        break;
      }
      String $73;
      final $76 = _matchString('default');
      if (_success) {
        $73 = $76;
        $9 = $73;
        break;
      }
      String $77;
      final $80 = _matchString('deferred');
      if (_success) {
        $77 = $80;
        $9 = $77;
        break;
      }
      String $81;
      final $84 = _matchString('descending');
      if (_success) {
        $81 = $84;
        $9 = $81;
        break;
      }
      String $85;
      final $88 = _matchString('do');
      if (_success) {
        $85 = $88;
        $9 = $85;
        break;
      }
      String $89;
      final $92 = _matchString('dynamic');
      if (_success) {
        $89 = $92;
        $9 = $89;
        break;
      }
      String $93;
      final $96 = _matchString('else');
      if (_success) {
        $93 = $96;
        $9 = $93;
        break;
      }
      String $97;
      final $100 = _matchString('enum');
      if (_success) {
        $97 = $100;
        $9 = $97;
        break;
      }
      String $101;
      final $104 = _matchString('export');
      if (_success) {
        $101 = $104;
        $9 = $101;
        break;
      }
      String $105;
      final $108 = _matchString('extends');
      if (_success) {
        $105 = $108;
        $9 = $105;
        break;
      }
      String $109;
      final $112 = _matchString('external');
      if (_success) {
        $109 = $112;
        $9 = $109;
        break;
      }
      String $113;
      final $116 = _matchString('factory');
      if (_success) {
        $113 = $116;
        $9 = $113;
        break;
      }
      String $117;
      final $120 = _matchString('false');
      if (_success) {
        $117 = $120;
        $9 = $117;
        break;
      }
      String $121;
      final $124 = _matchString('final');
      if (_success) {
        $121 = $124;
        $9 = $121;
        break;
      }
      String $125;
      final $128 = _matchString('finally');
      if (_success) {
        $125 = $128;
        $9 = $125;
        break;
      }
      String $129;
      final $132 = _matchString('for');
      if (_success) {
        $129 = $132;
        $9 = $129;
        break;
      }
      String $133;
      final $136 = _matchString('from');
      if (_success) {
        $133 = $136;
        $9 = $133;
        break;
      }
      String $137;
      final $140 = _matchString('get');
      if (_success) {
        $137 = $140;
        $9 = $137;
        break;
      }
      String $141;
      final $144 = _matchString('groupby');
      if (_success) {
        $141 = $144;
        $9 = $141;
        break;
      }
      String $145;
      final $148 = _matchString('hide');
      if (_success) {
        $145 = $148;
        $9 = $145;
        break;
      }
      String $149;
      final $152 = _matchString('if');
      if (_success) {
        $149 = $152;
        $9 = $149;
        break;
      }
      String $153;
      final $156 = _matchString('implements');
      if (_success) {
        $153 = $156;
        $9 = $153;
        break;
      }
      String $157;
      final $160 = _matchString('import');
      if (_success) {
        $157 = $160;
        $9 = $157;
        break;
      }
      String $161;
      final $164 = _matchString('in');
      if (_success) {
        $161 = $164;
        $9 = $161;
        break;
      }
      String $165;
      final $168 = _matchString('interface');
      if (_success) {
        $165 = $168;
        $9 = $165;
        break;
      }
      String $169;
      final $172 = _matchString('into');
      if (_success) {
        $169 = $172;
        $9 = $169;
        break;
      }
      String $173;
      final $176 = _matchString('is');
      if (_success) {
        $173 = $176;
        $9 = $173;
        break;
      }
      String $177;
      final $180 = _matchString('join');
      if (_success) {
        $177 = $180;
        $9 = $177;
        break;
      }
      String $181;
      final $184 = _matchString('let');
      if (_success) {
        $181 = $184;
        $9 = $181;
        break;
      }
      String $185;
      final $188 = _matchString('library');
      if (_success) {
        $185 = $188;
        $9 = $185;
        break;
      }
      String $189;
      final $192 = _matchString('mixin');
      if (_success) {
        $189 = $192;
        $9 = $189;
        break;
      }
      String $193;
      final $196 = _matchString('new');
      if (_success) {
        $193 = $196;
        $9 = $193;
        break;
      }
      String $197;
      final $200 = _matchString('null');
      if (_success) {
        $197 = $200;
        $9 = $197;
        break;
      }
      String $201;
      final $204 = _matchString('on');
      if (_success) {
        $201 = $204;
        $9 = $201;
        break;
      }
      String $205;
      final $208 = _matchString('operator');
      if (_success) {
        $205 = $208;
        $9 = $205;
        break;
      }
      String $209;
      final $212 = _matchString('orderby');
      if (_success) {
        $209 = $212;
        $9 = $209;
        break;
      }
      String $213;
      final $216 = _matchString('part');
      if (_success) {
        $213 = $216;
        $9 = $213;
        break;
      }
      String $217;
      final $220 = _matchString('rethrow');
      if (_success) {
        $217 = $220;
        $9 = $217;
        break;
      }
      String $221;
      final $224 = _matchString('return');
      if (_success) {
        $221 = $224;
        $9 = $221;
        break;
      }
      String $225;
      final $228 = _matchString('select');
      if (_success) {
        $225 = $228;
        $9 = $225;
        break;
      }
      String $229;
      final $232 = _matchString('set');
      if (_success) {
        $229 = $232;
        $9 = $229;
        break;
      }
      String $233;
      final $236 = _matchString('show');
      if (_success) {
        $233 = $236;
        $9 = $233;
        break;
      }
      String $237;
      final $240 = _matchString('static');
      if (_success) {
        $237 = $240;
        $9 = $237;
        break;
      }
      String $241;
      final $244 = _matchString('super');
      if (_success) {
        $241 = $244;
        $9 = $241;
        break;
      }
      String $245;
      final $248 = _matchString('switch');
      if (_success) {
        $245 = $248;
        $9 = $245;
        break;
      }
      String $249;
      final $252 = _matchString('sync');
      if (_success) {
        $249 = $252;
        $9 = $249;
        break;
      }
      String $253;
      final $256 = _matchString('this');
      if (_success) {
        $253 = $256;
        $9 = $253;
        break;
      }
      String $257;
      final $260 = _matchString('throw');
      if (_success) {
        $257 = $260;
        $9 = $257;
        break;
      }
      String $261;
      final $264 = _matchString('true');
      if (_success) {
        $261 = $264;
        $9 = $261;
        break;
      }
      String $265;
      final $268 = _matchString('try');
      if (_success) {
        $265 = $268;
        $9 = $265;
        break;
      }
      String $269;
      final $272 = _matchString('typedef');
      if (_success) {
        $269 = $272;
        $9 = $269;
        break;
      }
      String $273;
      final $276 = _matchString('var');
      if (_success) {
        $273 = $276;
        $9 = $273;
        break;
      }
      String $277;
      final $280 = _matchString('void');
      if (_success) {
        $277 = $280;
        $9 = $277;
        break;
      }
      String $281;
      final $284 = _matchString('where');
      if (_success) {
        $281 = $284;
        $9 = $281;
        break;
      }
      String $285;
      final $288 = _matchString('while');
      if (_success) {
        $285 = $288;
        $9 = $285;
        break;
      }
      String $289;
      final $292 = _matchString('with');
      if (_success) {
        $289 = $292;
        $9 = $289;
        break;
      }
      String $293;
      final $296 = _matchString('yield');
      if (_success) {
        $293 = $296;
        $9 = $293;
        break;
      }
      break;
    }
    if (_success) {
      final $297 = _c;
      final $298 = _pos;
      final $299 = _error;
      final $300 = _expected;
      final $301 = _failure;
      final $302 = $1;
      $1 = false;
      _parse$$identCont(false, false);
      _success = !_success;
      _c = $297;
      _pos = $298;
      _error = $299;
      _expected = $300;
      _failure = $301;
      $1 = $302;
      if (_success) {
        $6 = $9;
      } else {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    return $2;
  }

  int _parse$$char(bool $0, bool $1) {
    int $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      int $6;
      final $7 = _c;
      final $8 = _pos;
      _matchChar(92);
      if (_success) {
        final $10 = _parse$$escaped(false, $1);
        if (_success) {
          $6 = $10;
        } else {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      int $11;
      final $14 = _parse$$unescaped(false, $1);
      if (_success) {
        $11 = $14;
        $2 = $11;
        break;
      }
      break;
    }
    return $2;
  }

  int _parse$$escaped(bool $0, bool $1) {
    int $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      int $6;
      final $9 = _matchChar(34);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      int $10;
      final $13 = _matchChar(92);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      int $14;
      final $17 = _matchChar(47);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      int $18;
      _matchChar(98);
      if (_success) {
        int $$;
        $$ = 0x8;
        $18 = $$;
      }
      if (_success) {
        $2 = $18;
        break;
      }
      int $22;
      _matchChar(102);
      if (_success) {
        int $$;
        $$ = 0xC;
        $22 = $$;
      }
      if (_success) {
        $2 = $22;
        break;
      }
      int $26;
      _matchChar(110);
      if (_success) {
        int $$;
        $$ = 0xA;
        $26 = $$;
      }
      if (_success) {
        $2 = $26;
        break;
      }
      int $30;
      _matchChar(114);
      if (_success) {
        int $$;
        $$ = 0xD;
        $30 = $$;
      }
      if (_success) {
        $2 = $30;
        break;
      }
      int $34;
      _matchChar(116);
      if (_success) {
        int $$;
        $$ = 0x9;
        $34 = $$;
      }
      if (_success) {
        $2 = $34;
        break;
      }
      int $38;
      final $39 = _c;
      final $40 = _pos;
      _matchChar(117);
      if (_success) {
        final $42 = _parse$$hexdig4(false, $1);
        if (_success) {
          $38 = $42;
        } else {
          _c = $39;
          _pos = $40;
        }
      }
      if (_success) {
        $2 = $38;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    return $2;
  }

  int _parse$$hexdig4(bool $0, bool $1) {
    int $2;
    final $3 = _pos;
    final $4 = _c;
    int $6;
    final $9 = _parse$$hexdig(false, $1);
    if (_success) {
      final $10 = _parse$$hexdig(false, $1);
      if (_success) {
        final $11 = _parse$$hexdig(false, $1);
        if (_success) {
          final $12 = _parse$$hexdig(false, $1);
          if (_success) {
            final a = $9;
            final b = $10;
            final c = $11;
            final d = $12;
            int $$;
            $$ = a * 0xfff + b * 0xff + c * 0xf + d;
            $6 = $$;
          }
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    return $2;
  }

  int _parse$$hexdig(bool $0, bool $1) {
    int $2;
    for (;;) {
      int $6;
      const $9 = [97, 102];
      _matchRanges($9);
      if (_success) {
        int $$;
        $$ = $$ - 97;
        $6 = $$;
      }
      if (_success) {
        $2 = $6;
        break;
      }
      int $11;
      const $14 = [65, 70];
      _matchRanges($14);
      if (_success) {
        int $$;
        $$ = $$ - 65;
        $11 = $$;
      }
      if (_success) {
        $2 = $11;
        break;
      }
      int $16;
      const $19 = [48, 57];
      _matchRanges($19);
      if (_success) {
        int $$;
        $$ = $$ - 48;
        $16 = $$;
      }
      if (_success) {
        $2 = $16;
        break;
      }
      break;
    }
    return $2;
  }

  int _parse$$unescaped(bool $0, bool $1) {
    int $2;
    for (;;) {
      int $6;
      const $9 = [32, 33];
      final $10 = _matchRanges($9);
      if (_success) {
        $6 = $10;
        $2 = $6;
        break;
      }
      int $11;
      const $14 = [35, 91];
      final $15 = _matchRanges($14);
      if (_success) {
        $11 = $15;
        $2 = $11;
        break;
      }
      int $16;
      const $19 = [93, 1114111];
      final $20 = _matchRanges($19);
      if (_success) {
        $16 = $20;
        $2 = $16;
        break;
      }
      break;
    }
    return $2;
  }
}

class _Memo {
  final int id;

  final int pos;

  final result;

  final bool success;

  _Memo({
    this.id,
    this.pos,
    this.result,
    this.success,
  });
}

// ignore_for_file: unused_element
// ignore_for_file: unused_field
