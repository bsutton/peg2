# Globals

%{
part of '../../query_parser.dart';

Expression _buildAssignable(Expression expression, List selectors) {
  var result = expression;
  for (final element in selectors) {
    if (element is ArgumentsExpression) {
      result = CallExpression(result, element);
    } else {
      final kind = element[0];
      final value = element[1];
      if (kind == '[') {
        result = IndexerExpression(result, value as Expression);
      } else if (kind == '.') {
        result = MemberAccessExpression(result, value as IdentifierExpression);
      } else {
        throw StateError('Incorrect assignable selector: $element');
      }
    }
  }

  return result;
}

Expression _buildBinary(Expression head, List<List> tail) {
  Expression builder(Expression head, List tail) {
    final left = head;
    final right = tail[1] as Expression;
    final operator = tail[0] as String;
    return Expression.binary(operator, left, right);
  }

  return _buildTree(head, tail, builder);
}

Expression _buildTree(Expression head, List<List> tail,
    Expression Function(Expression head, List tail) builder) {
  var result = head;
  for (var i = 0; i < tail.length; i++) {
    result = builder(result, tail[i]);
  }

  return result;
}

Expression _postUnary(String operator, Expression expression) {
  if (operator == null) {
    return expression;
  }

  ExpressionKind kind;
  switch (operator) {
    case '--':
      kind = ExpressionKind.postDecrement;
      break;
    case '++':
      kind = ExpressionKind.postIncrement;
      break;
    default:
      throw StateError('Inavlid operator: $operator');
  }

  return UnaryExpression(kind, expression);
}

Expression _unary(String operator, Expression expression) {
  if (operator == null) {
    return expression;
  }

  ExpressionKind kind;
  switch (operator) {
    case '~':
      kind = ExpressionKind.bitwiseNot;
      break;
    case '!':
      kind = ExpressionKind.not;
      break;
    case '--':
      kind = ExpressionKind.preDecrement;
      break;
    case '++':
      kind = ExpressionKind.preIncrement;
      break;
    case '-':
      kind = ExpressionKind.unaryMinus;
      break;
    default:
      throw StateError('Inavlid operator: $operator');
  }

  return UnaryExpression(kind, expression);
}

}%

# Nonterminals

QueryExpression
QueryExpression =
  'leading spaces'? f:FromClause b:QueryBody 'end of file' { $$ = QueryExpression(f, b); }
  ;

FromClause
FromClause =
  'from' v:Parameter 'in' s:Expression { $$ = FromClause(v, s); }
  ;

QueryBody
QueryBody =
  b:QueryBodyClauses? s:SelectOrGroupClause c:QueryContinuation? { $$ = QueryBody(b, s, c); }
  ;

QueryBodyClauses =
  QueryBodyClause+
  ;

QueryBodyClause
QueryBodyClause =
  FromClause
  / LetClause
  / WhereClause
  / JoinClause
  / JoinIntoClause
  / OrderbyClause
  ;

LetClause
LetClause =
  'let' i:Parameter '=' e:Expression { $$ = LetClause(i, e); }
  ;

WhereClause
WhereClause =
  'where' p:Expression { $$ = WhereClause(p); }
  ;

JoinClause
JoinClause =
  'join' j:Parameter 'in' i:Expression 'on' o:Expression 'equals' e:Expression { $$ = JoinClause(j, i, o, e); }
  ;

JoinIntoClause
JoinIntoClause =
  'join' j:Parameter 'in' i:Expression 'on' o:Expression 'equals' e:Expression 'into' n:'identifier' { $$ = JoinIntoClause(j, i, o, e, n); }
  ;

OrderbyClause
OrderbyClause =
  'orderby' o:Orderings { $$ = OrderbyClause(o); }
  ;

List<Ordering>
Orderings =
  h:Ordering t:(',' v:Ordering)* { $$ = [h, ...t]; }
  ;

Ordering
Ordering =
  e:Expression o:OrderingDirection? { $$ = Ordering(e, o); }
  ;

OrderingDirection
OrderingDirection =
  'ascending' { $$ = OrderingDirection.ascending; }
  / 'descending' { $$ = OrderingDirection.descending; }
  ;

SelectOrGroupClause
SelectOrGroupClause =
  SelectClause
  / GroupClause
  ;

SelectClause
SelectClause =
  'select' r:Expression { $$ = SelectClause(r); }
  ;

GroupClause
GroupClause =
  'group' e:Expression 'by' k:Expression { $$ = GroupClause(e, k); }
  ;

QueryContinuation
QueryContinuation =
  'into' v:Identifier b:QueryBody { $$ = QueryContinuation(v, b); }
  ;

Expression
PrimaryExpression =
  Literal
  / Identifier
  / NewExpression
  / '(' v:Expression ')' { $$ = ParenthesesExpression(v); }
  ;

IdentifierExpression
Identifier =
  v:'identifier' { $$ = IdentifierExpression(v); }
  ;

Literal =
  NullLiteral
  / StringLiteral
  / ListLiteral
  / MapLiteral  
  / BooleanLiteral
  / NumericLiteral
  ;

Expression
NullLiteral =
  'null' { $$ = NullLiteralExpression(); }
  ;

Expression
StringLiteral =
  v:'string' { $$ = StringLiteralExpression(v); }
  ;

Expression
MapLiteral =
  a:TwoTypeArguments?  '{' e:MapEntries? '}' { $$ = MapLiteralExpression(e, a); }
  ;

List<MapEntryLiteralExpression>
MapEntries =
  h:MapEntry t:(',' v:MapEntry)* { $$ = [h, ...t]; }
  ;

MapEntryLiteralExpression
MapEntry =
  k:Expression ':' v:Expression { $$ = MapEntryLiteralExpression(k, v); }
  ;

Expression
ListLiteral =
  a:OneTypeArgument? '[' e:Elements? ']'  { $$ = ListLiteralExpression(e, a); }
  ;

List<Expression>
Elements =
  h:Expression t:(',' v:Expression)* { $$ = [h, ...t]; }
  ;

Expression
BooleanLiteral =
  v:('true' / 'false') { $$ = BooleanLiteralExpression(v); }
  ;

Expression
NumericLiteral =
  v:('number' / 'hex number') { $$ = NumericLiteralExpression(v); }
  ;

Expression
NewExpression =
  'new' '{'  '}' { throw UnimplementedError(); }
  ;

Expression
AssignableExpression =
  e:PrimaryExpression s:Selector+ { $$ = _buildAssignable(e, s); }
  / Identifier
  ;

AssignableSelector =
  k:'[' v:Expression ']'
  / k:'.' v:Identifier
  ;

Expression
Arguments =
  '(' v:ArgumentList? ')' { $$ = ArgumentsExpression(v); }
  ;

List<Expression>
ArgumentList =
    h:NamedArgument t:(',' v:NamedArgument)* { $$ = [h, ...t]; }
    / h:ExpressionList t:(',' v:NamedArgument)* { $$ = [...h, ...t]; }
    ;

NamedArgument =
  LabeledExpression
  ;

LabeledExpression
LabeledExpression =
  l:'identifier' ':' e:Expression { $$ = LabeledExpression(l, e); }
  ;

List<Expression>
ExpressionList =
  h:Expression t:(',' v:Expression)* { $$ = [h, ...t]; }
  ;

Expression
PostfixExpression =
  e:AssignableExpression o:IncrementOperator { $$ = _postUnary(o, e); }
  / e:AssignableExpression s:Selector* { $$ = _buildAssignable(e, s); }
  / PrimaryExpression
  ;


Selector =
  AssignableSelector
  / Arguments
  ;

IncrementOperator =
  '++'
  / '--'
  ;

Expression
UnaryExpression =
  o:PrefixOperator e:UnaryExpression { $$ = _unary(o, e); }
  / PostfixExpression
  / o:IncrementOperator e:AssignableExpression { $$ = _unary(o, e); }
  ;

PrefixOperator =
  '-'
  / '~'
  / '!'
  ;

Expression
MultiplicativeExpression =
  h:UnaryExpression t:(o:MultiplicativeOperator e:UnaryExpression)* { $$ = _buildBinary(h, t); }
  ;

MultiplicativeOperator =
  '*'
  / '/'
  / '%'
  / '~/'
  ;

Expression
AdditiveExpression =
  h:MultiplicativeExpression t:(o:AdditiveOperator e:MultiplicativeExpression)* { $$ = _buildBinary(h, t); }
  ;

AdditiveOperator =
  '+'
  / '-'
  ;

Expression
ShiftExpression =
  h:AdditiveExpression t:(o:ShiftOperator e:AdditiveExpression)* { $$ = _buildBinary(h, t); }
  ;

ShiftOperator =
  '<<'
  / '>>>'
  / '>>'
  ;

Expression
RelationalExpression =
  h:ShiftExpression t:(o:RelationalOperator e:ShiftExpression)* { $$ = _buildBinary(h, t); }
  ;

RelationalOperator =
  '<='
  / '>='
  / '<'
  / '>'
  ;

Expression
EqualityExpression =
  h:RelationalExpression t:(o:EqualityOperator e:RelationalExpression)* { $$ = _buildBinary(h, t); }
  ;

EqualityOperator =
  '=='
  / '!='
  ;

Expression
BitwiseAndExpression =
  h:EqualityExpression t:(o:BitwiseAndOperator e:EqualityExpression)* { $$ = _buildBinary(h, t); }
  ;

BitwiseAndOperator =
  '&'  
  ;

Expression
BitwiseXorExpression =
  h:BitwiseAndExpression t:(o:BitwiseXorOperator e:BitwiseAndExpression)* { $$ = _buildBinary(h, t); }
  ;

BitwiseXorOperator =
  '^'  
  ;

Expression
BitwiseOrExpression =
  h:BitwiseXorExpression t:(o:BitwiseOrOperator e:BitwiseXorExpression)* { $$ = _buildBinary(h, t); }
  ;

BitwiseOrOperator =
  '|'  
  ;

Expression
LogicalAndExpression =
  h:BitwiseOrExpression t:(o:LogicalAndOperator e:BitwiseOrExpression)* { $$ = _buildBinary(h, t); }
  ;

LogicalAndOperator =
  '&&'  
  ;

Expression
LogicalOrExpression =
  h:LogicalAndExpression t:(o:LogicalOrOperator e:LogicalAndExpression)* { $$ = _buildBinary(h, t); }
  ;

LogicalOrOperator =
  '||'  
  ;

Expression
ConditionalExpression =
  e:LogicalOrExpression '?' t:AssignmentExpression ':' f:AssignmentExpression { $$ = ConditionalExpression(e, t, f); }
  / LogicalOrExpression
  ;

Expression
AssignmentExpression =
  l:UnaryExpression o:AssignmentOperator r:AssignmentExpression { $$ = Expression.binary(o, l, r); }
  / ConditionalExpression
  ;

AssignmentOperator =
   '='
  / '*='
  / '/='
  / '~/='
  / '%='
  / '+='
  / '-='
  / '<<='
  / '>>='
  / '>>>='
  / '&='
  / '^='
  / '|='
  ;

Expression
Expression =
  l:AssignableExpression o:AssignmentOperator r:Expression { $$ = Expression.binary(o, l, r); }
  / ConditionalExpression
  ;

ParameterExpression
Parameter =
  t:Type i:Identifier { $$ = ParameterExpression(i, t); }
  / i:Identifier { $$ = ParameterExpression(i, null); }
  ;

TypeExpression
Type =
  i:Identifier a:TypeArguments? { $$ = TypeExpression(i, a); }
  ;

TypeArgumentsExpression
TypeArguments =
  '<' v:TypeArgumentList '>'  { $$ = TypeArgumentsExpression(v); }
  ;

List<TypeExpression>
TypeArgumentList =
  h:Type t:(',' v:Type)* { $$ = [h, ...t]; }
  ;

TypeArgumentsExpression
OneTypeArgument =
  '<' v:Type '>'  { $$ = TypeArgumentsExpression([v]); }
  ;

TypeArgumentsExpression
TwoTypeArguments =
  '<' f:Type ','  n:Type '>'  { $$ = TypeArgumentsExpression([f, n]); }
  ;

# Terminals

'leading spaces' =
  @whitespace
  ;

'end of file' =
  !.
  ;

'from' =
  "from" @whitespace
  ;

String
'identifier' =
  <!@keywords @identStart @identCont*> @whitespace
  ;

'in' =
  "in" @whitespace
  ;

'let' =
  "let" @whitespace
  ;

'=' =
  "=" @whitespace
  ;

'where' =
  "where" @whitespace
  ;

'join' =
  "join" @whitespace
  ;

'on' =
  "on" @whitespace
  ;

'equals' =
  "equals" @whitespace
  ;

'into' =
  "into" @whitespace
  ;

'orderby' =
  "orderby" @whitespace
  ;

',' =
  "," @whitespace
  ;

'ascending' =
  "ascending" @whitespace
  ;

'descending' =
  "descending" @whitespace
  ;

'select' =
  "select" @whitespace
  ;

'group' =
  "group" @whitespace
  ;

'by' =
  "by" @whitespace
  ;

'new' =
  "new" @whitespace
  ;

String
'string' =
  "\"" c:@char* "\"" @whitespace { $$ = String.fromCharCodes(c); }
  ;

num
'number' =
  n:<[-]? ([0] / [1-9] [0-9]*) ([.] [0-9]+)? ([eE] [+-]? [0-9]+)?> @whitespace { $$ = num.parse(n); }
  ;

num
'hex number' =
  v:<"0" [xX] @hexdig+> { $$ = num.parse(v); }
  ;

bool
'true' =
  "true" @whitespace { $$ = true; }
  ;

bool
'false' =
  "false" @whitespace { $$ = false; }
  ;

'null' =
  "null" @whitespace { $$ = null; }
  ;

'+' =
  "+" @whitespace
  ;

'-' =
  "-" @whitespace
  ;

'/' =
  "/" @whitespace
  ;

'*' =
  "*" @whitespace
  ;

'~' =
  "~" @whitespace
  ;

'!' =
  "!" @whitespace
  ;

'++' =
  "++" @whitespace
  ;

'--' =
  "--" @whitespace
  ;

'(' =
  "(" @whitespace
  ;

')' =
  ")" @whitespace
  ;

'{' =
  "{" @whitespace
  ;

'}' =
  "}" @whitespace
  ;

'[' =
  "[" @whitespace
  ;

']' =
  "]" @whitespace
  ;

':' =
  ":" @whitespace
  ;

'*=' =
  "*=" @whitespace
  ;

'/=' =
  "/=" @whitespace
  ;

'~/=' =
  "~/=" @whitespace
  ;

'%=' =
  "%=" @whitespace
  ;

'+=' =
  "+=" @whitespace
  ;

'-=' =
  "-=" @whitespace
  ;

'<<=' =
  "<<=" @whitespace
  ;

'>>>=' =
  ">>>=" @whitespace
  ;

'>>=' =
  ">>=" @whitespace
  ;

'&=' =
  "&=" @whitespace
  ;

'^=' =
  "^=" @whitespace
  ;

'|=' =
  "|=" @whitespace
  ;

'?' =
  "?" @whitespace
  ;

'||' =
  "||" @whitespace
  ;

'&&' =
  "&&" @whitespace
  ;

'==' =
  "==" @whitespace
  ;

'!=' =
  "!=" @whitespace
  ;

'>=' =
  ">=" @whitespace
  ;

'>' =
  ">" @whitespace
  ;

'<=' =
  "<=" @whitespace
  ;

'<' =
  "<" @whitespace
  ;

'|' =
  "|" @whitespace
  ;

'^' =
  "^" @whitespace
  ;

'&' =
  "&" @whitespace
  ;

'<<' =
  "<<" @whitespace
  ;

'>>>' =
  ">>>" @whitespace
  ;

'>>' =
  ">>" @whitespace
  ;

'%' =
  "%" @whitespace
  ;

'~/' =
  "~/" @whitespace
  ;

'.' =
  "." @whitespace
  ;

# Subterminals

@whitespace =
  [ \n\r\t]*
  ;

@identStart =
  [a-zA-Z]
  ;

@identCont =
  [_a-zA-Z0-9]
  ;

@keywords =
  ("Function"
  / "abstract"
  / "as"
  / "ascending"
  / "assert"
  / "async"
  / "await"
  / "break"
  / "by"
  / "case"
  / "catch"
  / "class"
  / "const"
  / "continue"
  / "covariant"
  / "default"
  / "deferred"
  / "descending"
  / "do"
  / "dynamic"
  / "else"
  / "enum"
  / "export"
  / "extends"
  / "external"
  / "factory"
  / "false"
  / "final"
  / "finally"
  / "for"
  / "from"
  / "get"
  / "groupby"
  / "hide"
  / "if"
  / "implements"
  / "import"
  / "in"
  / "interface"
  / "into"
  / "is"
  / "join"
  / "let"
  / "library"
  / "mixin"
  / "new"
  / "null"
  / "on"
  / "operator"
  / "orderby"
  / "part"
  / "rethrow"
  / "return"
  / "select"
  / "set"
  / "show"
  / "static"
  / "super"
  / "switch"
  / "sync"
  / "this"
  / "throw"
  / "true"
  / "try"
  / "typedef"
  / "var"
  / "void"
  / "where"
  / "while"
  / "with"
  / "yield") !@identCont
  ;

@char =
  [\\] r:@escaped
  / @unescaped
  ;

int
@escaped =
  [\u22]
  / [\u5c]
  / [\u2f]
  / [\u62] { $$ = 0x8; }
  / [\u66] { $$ = 0xC; }
  / [\u6e] { $$ = 0xA; }
  / [\u72] { $$ = 0xD; }
  / [\u74] { $$ = 0x9; }
  / [\u75] r:@hexdig4
  ;

int
@hexdig4 =
  a:@hexdig b:@hexdig c:@hexdig d:@hexdig { $$ = a * 0xfff + b * 0xff + c * 0xf + d; }
  ;

int
@hexdig =
  [a-f] { $$ = $$ - 97; }
  / [A-F] { $$ = $$ - 65; }
  / [0-9]  { $$ = $$ - 48; }
  ;

@unescaped =
  [\u20-\u21]
  / [\u23-\u5b]
  / [\u5d-\u10ffff]
  ;
