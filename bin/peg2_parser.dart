// Generated by 'peg2'
// https://pub.dev/packages/peg2

import 'package:peg2/grammar.dart';
import 'package:peg2/expressions.dart';

int _escape(int c) {
  switch (c) {
    case 110:
      return 0xA;
    case 114:
      return 0xD;
    case 116:
      return 0x9;
  }

  return c;
}

Expression _prefix(String? prefix, Expression expression, String? variable) {
  switch (prefix) {
    case '&':
      expression = AndPredicateExpression(expression);
      break;
    case '!':
      expression = NotPredicateExpression(expression);
      break;
  }

  expression.variable = variable;
  return expression;
}

Expression _suffix(String? suffix, Expression expression) {
  switch (suffix) {
    case '?':
      return OptionalExpression(expression);
    case '*':
      return ZeroOrMoreExpression(expression);
    case '+':
      return OneOrMoreExpression(expression);
  }

  return expression;
}

class Peg2Parser {
  static const int _eof = 1114112;

  static const List<String> _terminals = [
    '\'non terminal name\'',
    '\'terminal name\'',
    '\'sub terminal name\'',
    '\'semantic value\'',
    '\'type name\'',
    '\'library prefix\'',
    '\';\'',
    '\'action\'',
    '\'&\'',
    '\'character class\'',
    '\')\'',
    '\'.\'',
    '\'end of file\'',
    '\'globals\'',
    '\'leading spaces\'',
    '\'=\'',
    '\'literal\'',
    '\'members\'',
    '\'!\'',
    '\'(\'',
    '\'+\'',
    '\',\'',
    '\'?\'',
    '\'/\'',
    '\'*\'',
    '\'<\'',
    '\'>\''
  ];

  FormatException? error;

  bool ok = false;

  int _ch = 0;

  int _failStart = -1;

  int _failures0 = 0;

  int _length = 0;

  int _pos = 0;

  String _source = '';

  String? _unterminated;

  Grammar? parse(String source) {
    _source = source;
    _reset();
    final result = _parseGrammar();
    if (!ok) {
      _buildError();
    }

    return result;
  }

  void _buildError() {
    final sink = StringBuffer();
    sink.write('Syntax error, ');
    if (_unterminated != null) {
      sink.write('unterminated ');
      sink.write(_unterminated);
    } else {
      final names = <String>[];
      final flags = <int>[];
      flags.add(_failures0);
      for (var i = 0, id = 0; i < flags.length; i++) {
        final flag = flags[i];
        for (var j = 0; j < 32; j++) {
          final mask = 1 << j;
          if (flag & mask != 0) {
            final name = _terminals[id];
            names.add(name);
          }

          id++;
        }
      }

      names.sort();
      if (names.isEmpty) {
        if (_failStart == _length) {
          sink.write('unexpected end of input');
        } else {
          sink.write('unexpected charcater ');
          final ch = _getChar(_failStart);
          if (ch >= 32 && ch < 126) {
            sink.write('\'');
            sink.write(String.fromCharCode(ch));
            sink.write('\'');
          } else {
            sink.write('(');
            sink.write(ch);
            sink.write(')');
          }
        }
      } else {
        sink.write('expected ');
        sink.write(names.join(', '));
      }
    }

    error = FormatException(sink.toString(), _source, _failStart);
  }

  @pragma('vm:prefer-inline')
  bool _fail(String name) {
    if (_failStart > _pos) {
      return false;
    }

    if (_failStart < _pos) {
      _failStart = _pos;
      _unterminated = null;
      _failures0 = 0;
    }

    return true;
  }

  @pragma('vm:prefer-inline')
  int _getChar(int pos) {
    if (pos < _source.length) {
      _ch = _source.codeUnitAt(pos);
      if (_ch >= 0xD800) {
        return _getChar32(pos);
      }

      return _ch;
    }

    return _eof;
  }

  @pragma('vm:prefer-inline')
  int _getChar32(int pos) {
    if (_ch >= 0xD800 && _ch <= 0xDBFF) {
      if (pos + 1 < _source.length) {
        final ch2 = _source.codeUnitAt(pos + 1);
        if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {
          _ch = ((_ch - 0xD800) << 10) + (ch2 - 0xDC00) + 0x10000;
        } else {
          throw FormatException('Unpaired high surrogate', _source, pos);
        }
      } else {
        throw FormatException('The source has been exhausted', _source, pos);
      }
    } else {
      if (_ch >= 0xDC00 && _ch <= 0xDFFF) {
        throw FormatException(
            'UTF-16 surrogate values are illegal in UTF-32', _source, pos);
      }
    }

    return _ch;
  }

  @pragma('vm:prefer-inline')
  int? _matchAny() {
    if (_ch == _eof) {
      ok = false;
      return null;
    }

    final ch = _ch;
    _pos += _ch <= 0xffff ? 1 : 2;
    _ch = _getChar(_pos);
    ok = true;
    return ch;
  }

  @pragma('vm:prefer-inline')
  int? _matchRange(int start, int end) {
    if (_ch >= start && _ch <= end) {
      final ch = _ch;
      _pos += _ch <= 0xffff ? 1 : 2;
      _ch = _getChar(_pos);
      ok = true;
      return ch;
    }

    ok = false;
    return null;
  }

  @pragma('vm:prefer-inline')
  int? _matchRanges(List<int> ranges) {
    // Use binary search
    for (var i = 0; i < ranges.length; i += 2) {
      if (ranges[i] <= _ch) {
        if (ranges[i + 1] >= _ch) {
          final ch = _ch;
          _pos += _ch <= 0xffff ? 1 : 2;
          _ch = _getChar(_pos);
          ok = true;
          return ch;
        }
      } else {
        break;
      }
    }

    ok = false;
    return null;
  }

  @pragma('vm:prefer-inline')
  T _nextChar<T>(T value) {
    ok = true;
    _pos += _ch <= 0xffff ? 1 : 2;
    if (_pos < _source.length) {
      _ch = _source.codeUnitAt(_pos);
      if (_ch >= 0xD800) {
        _ch = _getChar32(_pos);
      }

      return value;
    }

    _ch = _eof;
    return value;
  }

  dynamic _parse$$ACTION_BODY() {
    final $0 = _ch;
    final $1 = _pos;
    ok = false;
    if (_ch == 123) {
      _nextChar('{');
    }
    if (ok) {
      do {
        _parse$$ACTION_BODY();
      } while (ok);
      ok = true;
      ok = false;
      if (_ch == 125) {
        _nextChar('}');
      }
    }
    if (ok) {
      return null;
    }
    _ch = $0;
    _pos = $1;
    ok = !_source.startsWith('}', _pos);
    if (ok) {
      _matchAny();
    }
    if (ok) {
      return null;
    }
    return null;
  }

  @pragma('vm:prefer-inline')
  String? _parse$$COMMENT() {
    ok = false;
    if (_ch == 35) {
      _nextChar('#');
    }
    if (ok) {
      do {
        final $0 = _ch;
        final $1 = _pos;
        _parse$$EOL();
        _ch = $0;
        _pos = $1;
        ok = !ok;
        if (ok) {
          _matchAny();
        }
      } while (ok);
      ok = true;
      _parse$$EOL();
      ok = true;
    }

    return null;
  }

  dynamic _parse$$EOL() {
    ok = _source.startsWith('\r\n', _pos);
    if (ok) {
      _ch = _getChar(_pos += 2);
    }
    if (ok) {
      return null;
    }
    ok = false;
    if (_ch == 10 || _ch == 13) {
      _nextChar(_ch);
    }
    if (ok) {
      return null;
    }
    return null;
  }

  @pragma('vm:prefer-inline')
  dynamic _parse$$GLOBALS_BODY() {
    ok = !_source.startsWith('}%', _pos);
    if (ok) {
      _matchAny();
    }

    return null;
  }

  int? _parse$$HEX_NUMBER() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = false;
    if (_ch == 92) {
      _nextChar(_ch);
    }
    if (ok) {
      ok = false;
      if (_ch == 117) {
        _nextChar('u');
      }
      if (ok) {
        String? $3;
        final $4 = _pos;
        var $5 = 0;
        do {
          ok = false;
          if (_ch >= 48 && _ch <= 57 ||
              _ch >= 65 && _ch <= 70 ||
              _ch >= 97 && _ch <= 102) {
            _nextChar(_ch);
          }
          $5++;
        } while (ok);
        ok = $5 != 1;

        if (ok) {
          $3 = _source.substring($4, _pos);
        }
        if (ok) {
          final d = $3!;
          int? $$;
          $$ = int.parse(d, radix: 16);
          $0 = $$;
        }
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
    }
    return $0;
  }

  String? _parse$$IDENTIFIER() {
    String? $0;
    final $1 = _pos;
    _parse$$IDENT_START();
    if (ok) {
      do {
        _parse$$IDENT_CONT();
      } while (ok);
      ok = true;
    }

    if (ok) {
      $0 = _source.substring($1, _pos);
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  int? _parse$$IDENT_CONT() {
    _parse$$IDENT_START();
    if (ok) {
      return null;
    }
    ok = false;
    if (_ch >= 48 && _ch <= 57 || _ch == 95) {
      _nextChar(_ch);
    }
    if (ok) {
      return null;
    }
    return null;
  }

  int? _parse$$IDENT_START() {
    ok = false;
    if (_ch >= 65 && _ch <= 90 || _ch >= 97 && _ch <= 122) {
      _nextChar(_ch);
    }

    return null;
  }

  @pragma('vm:prefer-inline')
  int? _parse$$LITERAL_CHAR() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = false;
    if (_ch == 92) {
      _nextChar('\\');
    }
    if (ok) {
      int? $3;
      ok = false;
      if (_ch == 34 || _ch == 92 || _ch == 110 || _ch == 114 || _ch == 116) {
        $3 = _nextChar(_ch);
      }
      if (ok) {
        final c = $3!;
        int? $$;
        $$ = _escape(c);
        $0 = $$;
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    $0 = _parse$$HEX_NUMBER();

    if (ok) {
      return $0;
    }
    ok = !_source.startsWith('\\', _pos);
    if (ok) {
      final $4 = _ch;
      final $5 = _pos;
      _parse$$EOL();
      _ch = $4;
      _pos = $5;
      ok = !ok;
      if (ok) {
        $0 = _matchAny();
        if (ok) {
          final c = $0!;
          $0 = c;
        }
      }
    }
    if (ok) {
      return $0;
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  List<int>? _parse$$RANGE() {
    List<int>? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parse$$RANGE_CHAR();
    if (ok) {
      ok = false;
      if (_ch == 45) {
        _nextChar('-');
      }
      if (ok) {
        final $4 = _parse$$RANGE_CHAR();
        if (ok) {
          final s = $3!;
          final e = $4!;
          List<int>? $$;
          $$ = [s, e];
          $0 = $$;
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    final $5 = _parse$$RANGE_CHAR();
    if (ok) {
      final c = $5!;
      List<int>? $$;
      $$ = [c, c];
      $0 = $$;
    }
    if (ok) {
      return $0;
    }
    return $0;
  }

  int? _parse$$RANGE_CHAR() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = false;
    if (_ch == 92) {
      _nextChar('\\');
    }
    if (ok) {
      int? $3;
      ok = false;
      if (_ch >= 92 && _ch <= 93 || _ch == 110 || _ch == 114 || _ch == 116) {
        $3 = _nextChar(_ch);
      }
      if (ok) {
        final c = $3!;
        int? $$;
        $$ = _escape(c);
        $0 = $$;
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    $0 = _parse$$HEX_NUMBER();

    if (ok) {
      return $0;
    }
    ok = false;
    if (_ch >= 92 && _ch <= 93) {
      _nextChar(_ch);
    }
    ok = !ok;
    if (ok) {
      final $4 = _ch;
      final $5 = _pos;
      _parse$$EOL();
      _ch = $4;
      _pos = $5;
      ok = !ok;
      if (ok) {
        $0 = _matchAny();
        if (ok) {
          final c = $0!;
          $0 = c;
        }
      }
    }
    if (ok) {
      return $0;
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  dynamic _parse$$SPACE() {
    ok = false;
    if (_ch == 9 || _ch == 32) {
      _nextChar(_ch);
    }
    if (ok) {
      return null;
    }
    _parse$$EOL();
    if (ok) {
      return null;
    }
    return null;
  }

  List? _parse$$SPACING() {
    do {
      while (true) {
        _parse$$SPACE();
        if (ok) {
          break;
        }
        _parse$$COMMENT();
        if (ok) {
          break;
        }
        break;
      }
    } while (ok);
    ok = true;

    return null;
  }

  @pragma('vm:prefer-inline')
  int? _parse$$TERMINAL_CHAR() {
    final $0 = _ch;
    final $1 = _pos;
    ok = _source.startsWith('//', _pos);
    if (ok) {
      _ch = _getChar(_pos += 2);
    }
    if (ok) {
      ok = false;
      if (_ch == 39) {
        _nextChar(_ch);
      }
    }
    if (ok) {
      return null;
    }
    _ch = $0;
    _pos = $1;
    ok = false;
    if (_ch >= 32 && _ch <= 38 || _ch >= 40 && _ch <= 126) {
      _nextChar(_ch);
    }
    if (ok) {
      return null;
    }
    return null;
  }

  @pragma('vm:prefer-inline')
  ProductionRule? _parseDefinition() {
    ProductionRule? $0;
    $0 = _parseNonterminalDefinition();
    if (ok) {
      final NonterminalDefinition = $0!;
      $0 = NonterminalDefinition;
    }
    if (ok) {
      return $0;
    }
    $0 = _parseTerminalDefinition();
    if (ok) {
      final TerminalDefinition = $0!;
      $0 = TerminalDefinition;
    }
    if (ok) {
      return $0;
    }
    $0 = _parseSubterminalDefinition();
    if (ok) {
      final SubterminalDefinition = $0!;
      $0 = SubterminalDefinition;
    }
    if (ok) {
      return $0;
    }
    return $0;
  }

  OrderedChoiceExpression? _parseExpression() {
    OrderedChoiceExpression? $0;
    final $1 = _parseSequence();
    if (ok) {
      List<SequenceExpression>? $2;
      final $3 = <SequenceExpression>[];
      while (true) {
        SequenceExpression? $4;
        final $5 = _ch;
        final $6 = _pos;
        _parse_$Slash();
        if (ok) {
          $4 = _parseSequence();
          if (ok) {
            final e = $4!;
            $4 = e;
          }
        }
        if (!ok) {
          _ch = $5;
          _pos = $6;
          break;
        }
        $3.add($4!);
      }
      if (ok = true) {
        $2 = $3;
      }
      final e = $1!;
      final n = $2!;
      OrderedChoiceExpression? $$;
      $$ = OrderedChoiceExpression([e, ...n]);
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  Grammar? _parseGrammar() {
    Grammar? $0;
    final $1 = _ch;
    final $2 = _pos;
    _parse_leading_spaces();
    final $3 = _parse_globals();
    ok = true;
    final $4 = _parse_members();
    ok = true;
    List<ProductionRule>? $5;
    final $6 = <ProductionRule>[];
    while (true) {
      final $7 = _parseDefinition();
      if (!ok) {
        break;
      }
      $6.add($7!);
    }
    if ($6.isNotEmpty) {
      $5 = $6;
      ok = true;
    }
    if (ok) {
      _parse_end_of_file();
      if (ok) {
        final g = $3;
        final m = $4;
        final d = $5!;
        Grammar? $$;
        $$ = Grammar(d, g, m);
        $0 = $$;
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  ProductionRule? _parseNonterminalDefinition() {
    ProductionRule? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parseType();
    if (ok) {
      final $4 = _parse_non_terminal_name();
      if (ok) {
        _parse_$EqualSign();
        if (ok) {
          final $5 = _parseNonterminalExpression();
          if (ok) {
            _parse_$Semicolon();
            if (ok) {
              final t = $3!;
              final n = $4!;
              final e = $5!;
              ProductionRule? $$;
              $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, t);
              $0 = $$;
            }
          }
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    final $6 = _parse_non_terminal_name();
    if (ok) {
      _parse_$EqualSign();
      if (ok) {
        final $7 = _parseNonterminalExpression();
        if (ok) {
          _parse_$Semicolon();
          if (ok) {
            final n = $6!;
            final e = $7!;
            ProductionRule? $$;
            $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, null);
            $0 = $$;
          }
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    return $0;
  }

  OrderedChoiceExpression? _parseNonterminalExpression() {
    OrderedChoiceExpression? $0;
    final $1 = _parseNonterminalSequence();
    if (ok) {
      List<SequenceExpression>? $2;
      final $3 = <SequenceExpression>[];
      while (true) {
        SequenceExpression? $4;
        final $5 = _ch;
        final $6 = _pos;
        _parse_$Slash();
        if (ok) {
          $4 = _parseNonterminalSequence();
          if (ok) {
            final e = $4!;
            $4 = e;
          }
        }
        if (!ok) {
          _ch = $5;
          _pos = $6;
          break;
        }
        $3.add($4!);
      }
      if (ok = true) {
        $2 = $3;
      }
      final e = $1!;
      final n = $2!;
      OrderedChoiceExpression? $$;
      $$ = OrderedChoiceExpression([e, ...n]);
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parseNonterminalPrefix() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parse_semantic_value();
    ok = true;
    String? $4;
    while (true) {
      $4 = _parse_$Ampersand();

      if (ok) {
        break;
      }
      $4 = _parse_$ExclamationMark();

      if (ok) {
        break;
      }
      break;
    }
    ok = true;
    final $5 = _parseNonterminalSuffix();
    if (ok) {
      final s = $3;
      final p = $4;
      final e = $5!;
      Expression? $$;
      $$ = _prefix(p, e, s);
      $0 = $$;
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parseNonterminalPrimary() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parse_non_terminal_name();
    if (ok) {
      final n = $3!;
      Expression? $$;
      $$ = NonterminalExpression(n);
      $0 = $$;
    }
    if (ok) {
      return $0;
    }
    final $4 = _parse_terminal_name();
    if (ok) {
      final n = $4!;
      Expression? $$;
      $$ = TerminalExpression(n);
      $0 = $$;
    }
    if (ok) {
      return $0;
    }
    _parse_$LeftParenthesis();
    if (ok) {
      $0 = _parseNonterminalExpression();
      if (ok) {
        _parse_$RightParenthesis();
        if (ok) {
          final e = $0!;
          $0 = e;
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    return $0;
  }

  SequenceExpression? _parseNonterminalSequence() {
    SequenceExpression? $0;
    List<Expression>? $1;
    final $2 = <Expression>[];
    while (true) {
      final $3 = _parseNonterminalPrefix();
      if (!ok) {
        break;
      }
      $2.add($3!);
    }
    if ($2.isNotEmpty) {
      $1 = $2;
      ok = true;
    }
    if (ok) {
      final $4 = _parse_action();
      ok = true;
      final e = $1!;
      final a = $4;
      SequenceExpression? $$;
      $$ = SequenceExpression(e, a);
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parseNonterminalSuffix() {
    Expression? $0;
    final $1 = _parseNonterminalPrimary();
    if (ok) {
      String? $2;
      while (true) {
        $2 = _parse_$QuestionMark();

        if (ok) {
          break;
        }
        $2 = _parse_$Asterisk();

        if (ok) {
          break;
        }
        $2 = _parse_$PlusSign();

        if (ok) {
          break;
        }
        break;
      }
      ok = true;
      final e = $1!;
      final s = $2;
      Expression? $$;
      $$ = _suffix(s, e);
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parsePrefix() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parse_semantic_value();
    ok = true;
    String? $4;
    while (true) {
      $4 = _parse_$Ampersand();

      if (ok) {
        break;
      }
      $4 = _parse_$ExclamationMark();

      if (ok) {
        break;
      }
      break;
    }
    ok = true;
    final $5 = _parseSuffix();
    if (ok) {
      final s = $3;
      final p = $4;
      final e = $5!;
      Expression? $$;
      $$ = _prefix(p, e, s);
      $0 = $$;
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parsePrimary() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parse_sub_terminal_name();
    if (ok) {
      final n = $3!;
      Expression? $$;
      $$ = SubterminalExpression(n);
      $0 = $$;
    }
    if (ok) {
      return $0;
    }
    _parse_$LeftParenthesis();
    if (ok) {
      $0 = _parseExpression();
      if (ok) {
        _parse_$RightParenthesis();
        if (ok) {
          final e = $0!;
          $0 = e;
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    $0 = _parse_literal();

    if (ok) {
      return $0;
    }
    $0 = _parse_character_class();

    if (ok) {
      return $0;
    }
    _parse_$Period();
    if (ok) {
      Expression? $$;
      $$ = AnyCharacterExpression();
      $0 = $$;
    }
    if (ok) {
      return $0;
    }
    _parse_$LessThanSign();
    if (ok) {
      final $4 = _parseExpression();
      if (ok) {
        _parse_$GreaterThanSign();
        if (ok) {
          final e = $4!;
          Expression? $$;
          $$ = CaptureExpression(e);
          $0 = $$;
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    return $0;
  }

  SequenceExpression? _parseSequence() {
    SequenceExpression? $0;
    List<Expression>? $1;
    final $2 = <Expression>[];
    while (true) {
      final $3 = _parsePrefix();
      if (!ok) {
        break;
      }
      $2.add($3!);
    }
    if ($2.isNotEmpty) {
      $1 = $2;
      ok = true;
    }
    if (ok) {
      final $4 = _parse_action();
      ok = true;
      final e = $1!;
      final a = $4;
      SequenceExpression? $$;
      $$ = SequenceExpression(e, a);
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  ProductionRule? _parseSubterminalDefinition() {
    ProductionRule? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parseType();
    if (ok) {
      final $4 = _parse_sub_terminal_name();
      if (ok) {
        _parse_$EqualSign();
        if (ok) {
          final $5 = _parseExpression();
          if (ok) {
            _parse_$Semicolon();
            if (ok) {
              final t = $3!;
              final n = $4!;
              final e = $5!;
              ProductionRule? $$;
              $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, t);
              $0 = $$;
            }
          }
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    final $6 = _parse_sub_terminal_name();
    if (ok) {
      _parse_$EqualSign();
      if (ok) {
        final $7 = _parseExpression();
        if (ok) {
          _parse_$Semicolon();
          if (ok) {
            final n = $6!;
            final e = $7!;
            ProductionRule? $$;
            $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, null);
            $0 = $$;
          }
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parseSuffix() {
    Expression? $0;
    final $1 = _parsePrimary();
    if (ok) {
      String? $2;
      while (true) {
        $2 = _parse_$QuestionMark();

        if (ok) {
          break;
        }
        $2 = _parse_$Asterisk();

        if (ok) {
          break;
        }
        $2 = _parse_$PlusSign();

        if (ok) {
          break;
        }
        break;
      }
      ok = true;
      final e = $1!;
      final s = $2;
      Expression? $$;
      $$ = _suffix(s, e);
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  ProductionRule? _parseTerminalDefinition() {
    ProductionRule? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parseType();
    if (ok) {
      final $4 = _parse_terminal_name();
      if (ok) {
        _parse_$EqualSign();
        if (ok) {
          final $5 = _parseExpression();
          if (ok) {
            _parse_$Semicolon();
            if (ok) {
              final t = $3!;
              final n = $4!;
              final e = $5!;
              ProductionRule? $$;
              $$ = ProductionRule(n, ProductionRuleKind.terminal, e, t);
              $0 = $$;
            }
          }
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    final $6 = _parse_terminal_name();
    if (ok) {
      _parse_$EqualSign();
      if (ok) {
        final $7 = _parseExpression();
        if (ok) {
          _parse_$Semicolon();
          if (ok) {
            final n = $6!;
            final e = $7!;
            ProductionRule? $$;
            $$ = ProductionRule(n, ProductionRuleKind.terminal, e, null);
            $0 = $$;
          }
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    return $0;
  }

  String? _parseType() {
    String? $0;
    final $1 = _parseTypeName();
    if (ok) {
      List<String>? $2;
      final $3 = _ch;
      final $4 = _pos;
      _parse_$LessThanSign();
      if (ok) {
        $2 = _parseTypeArguments();
        if (ok) {
          _parse_$GreaterThanSign();
          if (ok) {
            final a = $2!;
            $2 = a;
          }
        }
      }
      if (!ok) {
        _ch = $3;
        _pos = $4;
      }
      ok = true;
      final n = $1!;
      final a = $2;
      String? $$;
      $$ = n + (a == null ? '' : '<' + a.join(', ') + '>');
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  List<String>? _parseTypeArguments() {
    List<String>? $0;
    final $1 = _parseType();
    if (ok) {
      List<String>? $2;
      final $3 = <String>[];
      while (true) {
        String? $4;
        final $5 = _ch;
        final $6 = _pos;
        _parse_$Comma();
        if (ok) {
          $4 = _parseType();
          if (ok) {
            final t = $4!;
            $4 = t;
          }
        }
        if (!ok) {
          _ch = $5;
          _pos = $6;
          break;
        }
        $3.add($4!);
      }
      if (ok = true) {
        $2 = $3;
      }
      final t = $1!;
      final n = $2!;
      List<String>? $$;
      $$ = [t, ...n];
      $0 = $$;
    }

    return $0;
  }

  @pragma('vm:prefer-inline')
  String? _parseTypeName() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    final $3 = _parse_library_prefix();
    if (ok) {
      _parse_$Period();
      if (ok) {
        final $4 = _parse_type_name();
        if (ok) {
          final p = $3!;
          final n = $4!;
          String? $$;
          $$ = '$p.$n';
          $0 = $$;
        }
      }
    }
    if (ok) {
      return $0;
    }
    _ch = $1;
    _pos = $2;
    $0 = _parse_type_name();

    if (ok) {
      return $0;
    }
    return $0;
  }

  String? _parse_$Ampersand() {
    String? $0;
    ok = false;
    if (_ch == 38) {
      $0 = _nextChar('&');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'&\'')) {
        _failures0 |= 0x100;
      }
    }
    return $0;
  }

  String? _parse_$Asterisk() {
    String? $0;
    ok = false;
    if (_ch == 42) {
      $0 = _nextChar('*');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'*\'')) {
        _failures0 |= 0x1000000;
      }
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  String? _parse_$Comma() {
    ok = false;
    if (_ch == 44) {
      _nextChar(',');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\',\'')) {
        _failures0 |= 0x200000;
      }
    }
    return null;
  }

  String? _parse_$EqualSign() {
    ok = false;
    if (_ch == 61) {
      _nextChar('=');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'=\'')) {
        _failures0 |= 0x8000;
      }
    }
    return null;
  }

  String? _parse_$ExclamationMark() {
    String? $0;
    ok = false;
    if (_ch == 33) {
      $0 = _nextChar('!');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'!\'')) {
        _failures0 |= 0x40000;
      }
    }
    return $0;
  }

  String? _parse_$GreaterThanSign() {
    ok = false;
    if (_ch == 62) {
      _nextChar('>');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'>\'')) {
        _failures0 |= 0x4000000;
      }
    }
    return null;
  }

  String? _parse_$LeftParenthesis() {
    ok = false;
    if (_ch == 40) {
      _nextChar('(');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'(\'')) {
        _failures0 |= 0x80000;
      }
    }
    return null;
  }

  String? _parse_$LessThanSign() {
    ok = false;
    if (_ch == 60) {
      _nextChar('<');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'<\'')) {
        _failures0 |= 0x2000000;
      }
    }
    return null;
  }

  String? _parse_$Period() {
    ok = false;
    if (_ch == 46) {
      _nextChar('.');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'.\'')) {
        _failures0 |= 0x800;
      }
    }
    return null;
  }

  String? _parse_$PlusSign() {
    String? $0;
    ok = false;
    if (_ch == 43) {
      $0 = _nextChar('+');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'+\'')) {
        _failures0 |= 0x100000;
      }
    }
    return $0;
  }

  String? _parse_$QuestionMark() {
    String? $0;
    ok = false;
    if (_ch == 63) {
      $0 = _nextChar('?');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'?\'')) {
        _failures0 |= 0x400000;
      }
    }
    return $0;
  }

  String? _parse_$RightParenthesis() {
    ok = false;
    if (_ch == 41) {
      _nextChar(')');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\')\'')) {
        _failures0 |= 0x400;
      }
    }
    return null;
  }

  String? _parse_$Semicolon() {
    ok = false;
    if (_ch == 59) {
      _nextChar(';');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\';\'')) {
        _failures0 |= 0x40;
      }
    }
    return null;
  }

  String? _parse_$Slash() {
    ok = false;
    if (_ch == 47) {
      _nextChar('/');
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'/\'')) {
        _failures0 |= 0x800000;
      }
    }
    return null;
  }

  String? _parse_action() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = false;
    if (_ch == 123) {
      _nextChar('{');
    }
    if (ok) {
      final $3 = _pos;
      do {
        _parse$$ACTION_BODY();
      } while (ok);
      ok = true;

      if (ok) {
        $0 = _source.substring($3, _pos);
      }
      ok = false;
      if (_ch == 125) {
        _nextChar('}');
      }
      if (ok) {
        _parse$$SPACING();
        final b = $0!;
        $0 = b;
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
      if (_fail('\'action\'')) {
        _failures0 |= 0x80;
      }
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parse_character_class() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = false;
    if (_ch == 91) {
      _nextChar('[');
    }
    if (ok) {
      List<List<int>>? $3;
      final $4 = <List<int>>[];
      while (true) {
        List<int>? $5;
        ok = !_source.startsWith(']', _pos);
        if (ok) {
          $5 = _parse$$RANGE();
          if (ok) {
            final r = $5!;
            $5 = r;
          }
        }
        if (!ok) {
          break;
        }
        $4.add($5!);
      }
      if ($4.isNotEmpty) {
        $3 = $4;
        ok = true;
      }
      if (ok) {
        ok = false;
        if (_ch == 93) {
          _nextChar(']');
        }
        if (ok) {
          _parse$$SPACING();
          final r = $3!;
          Expression? $$;
          $$ = CharacterClassExpression(r);
          $0 = $$;
        }
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
      if (_fail('\'character class\'')) {
        _failures0 |= 0x200;
      }
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  dynamic _parse_end_of_file() {
    ok = _ch == 1114112;
    if (!ok) {
      if (_fail('\'end of file\'')) {
        _failures0 |= 0x1000;
      }
    }
    return null;
  }

  @pragma('vm:prefer-inline')
  String? _parse_globals() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = _source.startsWith('%{', _pos);
    if (ok) {
      _ch = _getChar(_pos += 2);
    }
    if (ok) {
      final $3 = _pos;
      do {
        _parse$$GLOBALS_BODY();
      } while (ok);
      ok = true;

      if (ok) {
        $0 = _source.substring($3, _pos);
      }
      ok = _source.startsWith('}%', _pos);
      if (ok) {
        _ch = _getChar(_pos += 2);
      }
      if (ok) {
        _parse$$SPACING();
        final b = $0!;
        $0 = b;
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
      if (_fail('\'globals\'')) {
        _failures0 |= 0x2000;
      }
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  List? _parse_leading_spaces() {
    _parse$$SPACING();

    return null;
  }

  @pragma('vm:prefer-inline')
  String? _parse_library_prefix() {
    String? $0;
    final $1 = _pos;
    final $2 = _ch;
    ok = false;
    if (_ch == 95) {
      _nextChar(_ch);
    }
    ok = true;
    _parse$$IDENTIFIER();
    if (!ok) {
      _ch = $2;
    }
    if (ok) {
      $0 = _source.substring($1, _pos);
    }

    if (!ok) {
      if (_fail('\'library prefix\'')) {
        _failures0 |= 0x20;
      }
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  Expression? _parse_literal() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = false;
    if (_ch == 34) {
      _nextChar(_ch);
    }
    if (ok) {
      List<int>? $3;
      final $4 = <int>[];
      while (true) {
        int? $5;
        ok = _ch != 34;
        if (ok) {
          $5 = _parse$$LITERAL_CHAR();
          if (ok) {
            final c = $5!;
            $5 = c;
          }
        }
        if (!ok) {
          break;
        }
        $4.add($5!);
      }
      if (ok = true) {
        $3 = $4;
      }
      ok = false;
      if (_ch == 34) {
        _nextChar(_ch);
      }
      if (ok) {
        _parse$$SPACING();
        final c = $3!;
        Expression? $$;
        $$ = LiteralExpression(String.fromCharCodes(c));
        $0 = $$;
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
      if (_fail('\'literal\'')) {
        _failures0 |= 0x10000;
      }
    }
    return $0;
  }

  @pragma('vm:prefer-inline')
  String? _parse_members() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    ok = false;
    if (_ch == 123) {
      _nextChar('{');
    }
    if (ok) {
      final $3 = _pos;
      do {
        _parse$$ACTION_BODY();
      } while (ok);
      ok = true;

      if (ok) {
        $0 = _source.substring($3, _pos);
      }
      ok = false;
      if (_ch == 125) {
        _nextChar('}');
      }
      if (ok) {
        _parse$$SPACING();
        final b = $0!;
        $0 = b;
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
      if (_fail('\'members\'')) {
        _failures0 |= 0x20000;
      }
    }
    return $0;
  }

  String? _parse_non_terminal_name() {
    String? $0;
    $0 = _parse$$IDENTIFIER();
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'non terminal name\'')) {
        _failures0 |= 0x1;
      }
    }
    return $0;
  }

  String? _parse_semantic_value() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    $0 = _parse$$IDENTIFIER();
    if (ok) {
      ok = false;
      if (_ch == 58) {
        _nextChar(':');
      }
    }
    if (!ok) {
      _ch = $1;
      _pos = $2;
      if (_fail('\'semantic value\'')) {
        _failures0 |= 0x8;
      }
    }
    return $0;
  }

  String? _parse_sub_terminal_name() {
    String? $0;
    final $1 = _pos;
    final $2 = _ch;
    ok = false;
    if (_ch == 64) {
      _nextChar(_ch);
    }
    if (ok) {
      _parse$$IDENTIFIER();
    }
    if (!ok) {
      _ch = $2;
    }
    if (ok) {
      $0 = _source.substring($1, _pos);
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'sub terminal name\'')) {
        _failures0 |= 0x4;
      }
    }
    return $0;
  }

  String? _parse_terminal_name() {
    String? $0;
    final $1 = _pos;
    final $2 = _ch;
    ok = false;
    if (_ch == 39) {
      _nextChar(_ch);
    }
    if (ok) {
      var $3 = 0;
      do {
        ok = _ch != 39;
        if (ok) {
          _parse$$TERMINAL_CHAR();
        }

        $3++;
      } while (ok);
      ok = $3 != 1;
      if (ok) {
        ok = false;
        if (_ch == 39) {
          _nextChar(_ch);
        }
      }
    }
    if (!ok) {
      _ch = $2;
    }
    if (ok) {
      $0 = _source.substring($1, _pos);
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'terminal name\'')) {
        _failures0 |= 0x2;
      }
    }
    return $0;
  }

  String? _parse_type_name() {
    String? $0;
    final $1 = _pos;
    _parse$$IDENTIFIER();
    if (ok) {
      ok = false;
      if (_ch == 63) {
        _nextChar(_ch);
      }
      ok = true;
    }

    if (ok) {
      $0 = _source.substring($1, _pos);
    }
    if (ok) {
      _parse$$SPACING();
    }
    if (!ok) {
      if (_fail('\'type name\'')) {
        _failures0 |= 0x10;
      }
    }
    return $0;
  }

  void _reset() {
    error = null;
    _failStart = 0;
    _failures0 = 0;
    _length = _source.length;
    _pos = 0;
    _unterminated = null;
    _ch = _getChar(0);
    ok = false;
  }
}
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
