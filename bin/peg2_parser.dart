// Generated by 'peg2'
// https://pub.dev/packages/peg2

import 'package:peg2/grammar.dart';
import 'package:peg2/expressions.dart';

int _escape(int c) {
  switch (c) {
    case 110:
      return 0xA;
    case 114:
      return 0xD;
    case 116:
      return 0x9;
  }

  return c;
}

Expression _prefix(String prefix, Expression expression, String variable) {
  switch (prefix) {
    case '&':
      expression = AndPredicateExpression(expression);
      break;
    case '!':
      expression = NotPredicateExpression(expression);
      break;
  }

  expression.variable = variable;
  return expression;
}

Expression _suffix(String suffix, Expression expression) {
  switch (suffix) {
    case '?':
      return OptionalExpression(expression);
    case '*':
      return ZeroOrMoreExpression(expression);
    case '+':
      return OneOrMoreExpression(expression);
  }

  return expression;
}

class Peg2Parser {
  static const _eof = 0x110000;

  FormatException error;

  int _c;

  int _error;

  List<String> _expected;

  int _failure;

  List<int> _input;

  List<List<_Memo>> _memos;

  var _mresult;

  int _pos;

  bool _predicate;

  dynamic _result;

  bool _success;

  String _text;

  dynamic parse(String text) {
    if (text == null) {
      throw ArgumentError.notNull('text');
    }
    _text = text;
    _input = _toRunes(text);
    _reset();
    final result = _parseGrammar(false, true);
    _buildError();
    _expected = null;
    _input = null;
    return result;
  }

  void _buildError() {
    if (_success) {
      error = null;
      return;
    }

    String escape(int c) {
      switch (c) {
        case 10:
          return r'\n';
        case 13:
          return r'\r';
        case 09:
          return r'\t';
        case _eof:
          return 'end of file';
      }
      return String.fromCharCode(c);
    }

    String getc(int position) {
      if (position < _text.length) {
        return "'${escape(_input[position])}'";
      }
      return 'end of file';
    }

    String report(String message, String source, int start) {
      if (start < 0 || start > source.length) {
        start = null;
      }

      final sb = StringBuffer();
      sb.write(message);
      var line = 0;
      var col = 0;
      var lineStart = 0;
      var started = false;
      if (start != null) {
        for (var i = 0; i < source.length; i++) {
          final c = source.codeUnitAt(i);
          if (!started) {
            started = true;
            lineStart = i;
            line++;
            col = 1;
          } else {
            col++;
          }
          if (c == 10) {
            started = false;
          }
          if (start == i) {
            break;
          }
        }
      }

      if (start == null) {
        sb.writeln('.');
      } else if (line == 0 || start == source.length) {
        sb.write(' (at offset ');
        sb.write(start);
        sb.writeln('):');
      } else {
        sb.write(' (at line ');
        sb.write(line);
        sb.write(', column ');
        sb.write(col);
        sb.writeln('):');
      }

      List<int> escape(int c) {
        switch (c) {
          case 9:
            return [92, 116];
          case 10:
            return [92, 110];
          case 13:
            return [92, 114];
          default:
            return [c];
        }
      }

      const max = 70;
      if (start != null) {
        final c1 = <int>[];
        final c2 = <int>[];
        final half = max ~/ 2;
        var cr = false;
        for (var i = start; i >= lineStart && c1.length < half; i--) {
          if (i == source.length) {
            c2.insert(0, 94);
          } else {
            final c = source.codeUnitAt(i);
            final escaped = escape(c);
            c1.insertAll(0, escaped);
            if (c == 10) {
              cr = true;
            }

            final r = i == start ? 94 : 32;
            for (var k = 0; k < escaped.length; k++) {
              c2.insert(0, r);
            }
          }
        }

        for (var i = start + 1;
            i < source.length && c1.length < max && !cr;
            i++) {
          final c = source.codeUnitAt(i);
          final escaped = escape(c);
          c1.addAll(escaped);
          if (c == 10) {
            break;
          }
        }

        final text1 = String.fromCharCodes(c1);
        final text2 = String.fromCharCodes(c2);
        sb.writeln(text1);
        sb.writeln(text2);
      }

      return sb.toString();
    }

    final temp = _expected.toList();
    temp.sort((e1, e2) => e1.compareTo(e2));
    final expected = temp.toSet();
    final hasMalformed = false;
    if (expected.isNotEmpty) {
      if (!hasMalformed) {
        final sb = StringBuffer();
        sb.write('Expected ');
        sb.write(expected.join(', '));
        sb.write(' but found ');
        sb.write(getc(_error));
        final title = sb.toString();
        final message = report(title, _text, _error);
        error = FormatException(message);
      } else {
        final reason = _error == _text.length ? 'Unterminated' : 'Malformed';
        final sb = StringBuffer();
        sb.write(reason);
        sb.write(' ');
        sb.write(expected.join(', '));
        final title = sb.toString();
        final message = report(title, _text, _error);
        error = FormatException(message);
      }
    } else {
      final sb = StringBuffer();
      sb.write('Unexpected character ');
      sb.write(getc(_error));
      final title = sb.toString();
      final message = report(title, _text, _error);
      error = FormatException(message);
    }
  }

  void _fail(List<String> expected) {
    if (_error < _failure) {
      _error = _failure;
      _expected = [];
    }
    if (_error == _failure) {
      _expected.addAll(expected);
    }
  }

  int _matchChar(int c) {
    int result;
    if (c == _c) {
      _success = true;
      _c = _input[_pos += _c <= 0xffff ? 1 : 2];
      result = c;
    } else {
      _success = false;
      _failure = _pos;
    }

    return result;
  }

  int _matchRanges(List<int> ranges) {
    int result;
    _success = false;
    for (var i = 0; i < ranges.length; i += 2) {
      if (ranges[i] <= _c) {
        if (ranges[i + 1] >= _c) {
          result = _c;
          _c = _input[_pos += _c <= 0xffff ? 1 : 2];
          _success = true;
          break;
        }
      } else {
        break;
      }
    }

    if (!_success) {
      _failure = _pos;
    }

    return result;
  }

  String _matchString(String text) {
    String result;
    final length = text.length;
    final rest = _text.length - _pos;
    final count = length > rest ? rest : length;
    var pos = _pos;
    var i = 0;
    for (; i < count; i++, pos++) {
      if (text.codeUnitAt(i) != _text.codeUnitAt(pos)) {
        break;
      }
    }

    if (_success = i == length) {
      _c = _input[_pos += length];
      result = text;
    } else {
      _failure = _pos + i;
    }

    return result;
  }

  bool _memoized(int id) {
    final memos = _memos[_pos];
    if (memos != null) {
      for (var i = 0; i < memos.length; i++) {
        final memo = memos[i];
        if (memo.id == id) {
          _pos = memo.pos;
          _mresult = memo.result;
          _success = memo.success;
          _c = _input[_pos];
          return true;
        }
      }
    }

    return false;
  }

  void _memoize(int id, int pos, result) {
    var memos = _memos[pos];
    if (memos == null) {
      memos = [];
      _memos[pos] = memos;
    }

    final memo = _Memo(
      id: id,
      pos: _pos,
      result: result,
      success: _success,
    );

    memos.add(memo);
  }

  void _reset() {
    _c = _input[0];
    _error = 0;
    _expected = [];
    _failure = -1;
    _memos = [];
    _memos.length = _input.length + 1;
    _pos = 0;
    _predicate = false;
    _success = false;
  }

  List<int> _toRunes(String source) {
    final length = source.length;
    final result = List<int>(length + 1);
    for (var pos = 0; pos < length;) {
      int c;
      final start = pos;
      final leading = source.codeUnitAt(pos++);
      if ((leading & 0xFC00) == 0xD800 && pos < length) {
        final trailing = source.codeUnitAt(pos);
        if ((trailing & 0xFC00) == 0xDC00) {
          c = 0x10000 + ((leading & 0x3FF) << 10) + (trailing & 0x3FF);
          pos++;
        } else {
          c = leading;
        }
      } else {
        c = leading;
      }

      result[start] = c;
    }

    result[length] = 0x110000;
    return result;
  }

  Grammar _parseGrammar(bool $0, bool $1) {
    Grammar $2;
    final $3 = _pos;
    final $4 = _c;
    Grammar $6;
    _parse_leading_spaces(false, false);
    final $11 = _parse_globals(false, $1);
    final $12 = $11;
    final $13 = _parse_members(false, $1);
    final $14 = $13;
    List<ProductionRule> $15;
    if ($1) {
      $15 = [];
    }
    var $16 = false;
    for (;;) {
      final $17 = _parseDefinition(false, $1);
      if (!_success) {
        _success = $16;
        if (!_success) {
          $15 = null;
        }
        break;
      }
      if ($1) {
        $15.add($17);
      }
      $16 = true;
    }
    if (_success) {
      _parse_end_of_file(false, false);
      if (_success) {
        final g = $12;
        final m = $14;
        final d = $15;
        Grammar $$;
        $$ = Grammar(d, g, m);
        $6 = $$;
      }
    }
    if (!_success) {
      _c = $4;
      _pos = $3;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'non terminal name\'',
        '\'terminal name\'',
        '\'sub terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $2;
  }

  ProductionRule _parseDefinition(bool $0, bool $1) {
    ProductionRule $2;
    final $3 = _pos;
    for (;;) {
      ProductionRule $6;
      final $9 = _parseNonterminalDefinition(false, $1);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      ProductionRule $10;
      final $13 = _parseTerminalDefinition(false, $1);
      if (_success) {
        $10 = $13;
        $2 = $10;
        break;
      }
      ProductionRule $14;
      final $17 = _parseSubterminalDefinition(false, $1);
      if (_success) {
        $14 = $17;
        $2 = $14;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'non terminal name\'',
        '\'terminal name\'',
        '\'sub terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $2;
  }

  ProductionRule _parseNonterminalDefinition(bool $0, bool $1) {
    ProductionRule $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      ProductionRule $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseType(true, $1);
      if (_success) {
        final $10 = _parse_non_terminal_name(true, $1);
        if (_success) {
          _parse_$EqualSign(true, false);
          if (_success) {
            final $12 = _parseNonterminalExpression(true, $1);
            if (_success) {
              _parse_$Semicolon(false, false);
              if (_success) {
                final t = $9;
                final n = $10;
                final e = $12;
                ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, t);
                $6 = $$;
              }
            }
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      ProductionRule $14;
      final $15 = _c;
      final $16 = _pos;
      final $17 = _parse_non_terminal_name(true, $1);
      if (_success) {
        _parse_$EqualSign(true, false);
        if (_success) {
          final $19 = _parseNonterminalExpression(true, $1);
          if (_success) {
            _parse_$Semicolon(false, false);
            if (_success) {
              final n = $17;
              final e = $19;
              ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, null);
              $14 = $$;
            }
          }
        }
        if (!_success) {
          _c = $15;
          _pos = $16;
        }
      }
      if (_success) {
        $2 = $14;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'non terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $2;
  }

  OrderedChoiceExpression _parseNonterminalExpression(bool $0, bool $1) {
    OrderedChoiceExpression $2;
    final $3 = _pos;
    if ($0 && _memoized(30)) {
      return _mresult as OrderedChoiceExpression;
    }
    final $5 = _pos;
    OrderedChoiceExpression $6;
    final $9 = _parseNonterminalSequence(false, $1);
    if (_success) {
      List<SequenceExpression> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        SequenceExpression $11;
        final $12 = _pos;
        final $13 = _c;
        SequenceExpression $15;
        _parse_$Slash(false, false);
        if (_success) {
          final $19 = _parseNonterminalSequence(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'/\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final e = $9;
      final n = $10;
      OrderedChoiceExpression $$;
      $$ = OrderedChoiceExpression([e, ...n]);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $5) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    if ($0) {
      _memoize(30, $3, $2);
    }
    return $2;
  }

  SequenceExpression _parseNonterminalSequence(bool $0, bool $1) {
    SequenceExpression $2;
    final $3 = _pos;
    SequenceExpression $6;
    List<Expression> $9;
    if ($1) {
      $9 = [];
    }
    var $10 = false;
    for (;;) {
      final $11 = _parseNonterminalPrefix(false, $1);
      if (!_success) {
        _success = $10;
        if (!_success) {
          $9 = null;
        }
        break;
      }
      if ($1) {
        $9.add($11);
      }
      $10 = true;
    }
    if (_success) {
      final $12 = _parse_action(false, $1);
      final $13 = $12;
      _success = true;
      final e = $9;
      final a = $13;
      SequenceExpression $$;
      $$ = SequenceExpression(e, a);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $2;
  }

  Expression _parseNonterminalPrefix(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parse_semantic_value(false, $1);
    final $10 = $9;
    String $11;
    for (;;) {
      String $15;
      final $18 = _parse_$Ampersand(false, $1);
      if (_success) {
        $15 = $18;
        $11 = $15;
        break;
      }
      String $19;
      final $22 = _parse_$ExclamationMark(false, $1);
      if (_success) {
        $19 = $22;
        $11 = $19;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'&\'', '\'!\'']);
    }
    final $23 = $11;
    final $24 = _parseNonterminalSuffix(false, $1);
    if (_success) {
      final s = $10;
      final p = $23;
      final e = $24;
      Expression $$;
      $$ = _prefix(p, e, s);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $2;
  }

  Expression _parseNonterminalSuffix(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parseNonterminalPrimary(false, $1);
    if (_success) {
      String $10;
      final $11 = _pos;
      for (;;) {
        String $14;
        final $17 = _parse_$QuestionMark(false, $1);
        if (_success) {
          $14 = $17;
          $10 = $14;
          break;
        }
        String $18;
        final $21 = _parse_$Asterisk(false, $1);
        if (_success) {
          $18 = $21;
          $10 = $18;
          break;
        }
        String $22;
        final $25 = _parse_$PlusSign(false, $1);
        if (_success) {
          $22 = $25;
          $10 = $22;
          break;
        }
        break;
      }
      if (!_success && _error == $11) {
        _fail(const ['\'?\'', '\'*\'', '\'+\'']);
      }
      final $26 = $10;
      _success = true;
      final e = $9;
      final s = $26;
      Expression $$;
      $$ = _suffix(s, e);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $2;
  }

  Expression _parseNonterminalPrimary(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $9 = _parse_non_terminal_name(true, $1);
      if (_success) {
        final n = $9;
        Expression $$;
        $$ = NonterminalExpression(n);
        $6 = $$;
      }
      if (_success) {
        $2 = $6;
        break;
      }
      Expression $10;
      final $13 = _parse_terminal_name(true, $1);
      if (_success) {
        final n = $13;
        Expression $$;
        $$ = TerminalExpression(n);
        $10 = $$;
      }
      if (_success) {
        $2 = $10;
        break;
      }
      Expression $14;
      final $15 = _c;
      final $16 = _pos;
      _parse_$LeftParenthesis(true, false);
      if (_success) {
        final $18 = _parseNonterminalExpression(true, $1);
        if (_success) {
          _parse_$RightParenthesis(false, false);
          if (_success) {
            $14 = $18;
          }
        }
        if (!_success) {
          _c = $15;
          _pos = $16;
        }
      }
      if (_success) {
        $2 = $14;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $2;
  }

  ProductionRule _parseTerminalDefinition(bool $0, bool $1) {
    ProductionRule $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      ProductionRule $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseType(true, $1);
      if (_success) {
        final $10 = _parse_terminal_name(true, $1);
        if (_success) {
          _parse_$EqualSign(true, false);
          if (_success) {
            final $12 = _parseExpression(true, $1);
            if (_success) {
              _parse_$Semicolon(false, false);
              if (_success) {
                final t = $9;
                final n = $10;
                final e = $12;
                ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.terminal, e, t);
                $6 = $$;
              }
            }
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      ProductionRule $14;
      final $15 = _c;
      final $16 = _pos;
      final $17 = _parse_terminal_name(true, $1);
      if (_success) {
        _parse_$EqualSign(true, false);
        if (_success) {
          final $19 = _parseExpression(true, $1);
          if (_success) {
            _parse_$Semicolon(false, false);
            if (_success) {
              final n = $17;
              final e = $19;
              ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.terminal, e, null);
              $14 = $$;
            }
          }
        }
        if (!_success) {
          _c = $15;
          _pos = $16;
        }
      }
      if (_success) {
        $2 = $14;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'terminal name\'', '\'library prefix\'', '\'type name\'']);
    }
    return $2;
  }

  OrderedChoiceExpression _parseExpression(bool $0, bool $1) {
    OrderedChoiceExpression $2;
    final $3 = _pos;
    if ($0 && _memoized(87)) {
      return _mresult as OrderedChoiceExpression;
    }
    final $5 = _pos;
    OrderedChoiceExpression $6;
    final $9 = _parseSequence(false, $1);
    if (_success) {
      List<SequenceExpression> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        SequenceExpression $11;
        final $12 = _pos;
        final $13 = _c;
        SequenceExpression $15;
        _parse_$Slash(false, false);
        if (_success) {
          final $19 = _parseSequence(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\'/\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final e = $9;
      final n = $10;
      OrderedChoiceExpression $$;
      $$ = OrderedChoiceExpression([e, ...n]);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $5) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    if ($0) {
      _memoize(87, $3, $2);
    }
    return $2;
  }

  SequenceExpression _parseSequence(bool $0, bool $1) {
    SequenceExpression $2;
    final $3 = _pos;
    SequenceExpression $6;
    List<Expression> $9;
    if ($1) {
      $9 = [];
    }
    var $10 = false;
    for (;;) {
      final $11 = _parsePrefix(false, $1);
      if (!_success) {
        _success = $10;
        if (!_success) {
          $9 = null;
        }
        break;
      }
      if ($1) {
        $9.add($11);
      }
      $10 = true;
    }
    if (_success) {
      final $12 = _parse_action(false, $1);
      final $13 = $12;
      _success = true;
      final e = $9;
      final a = $13;
      SequenceExpression $$;
      $$ = SequenceExpression(e, a);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $2;
  }

  Expression _parsePrefix(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parse_semantic_value(false, $1);
    final $10 = $9;
    String $11;
    for (;;) {
      String $15;
      final $18 = _parse_$Ampersand(false, $1);
      if (_success) {
        $15 = $18;
        $11 = $15;
        break;
      }
      String $19;
      final $22 = _parse_$ExclamationMark(false, $1);
      if (_success) {
        $19 = $22;
        $11 = $19;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'&\'', '\'!\'']);
    }
    final $23 = $11;
    final $24 = _parseSuffix(false, $1);
    if (_success) {
      final s = $10;
      final p = $23;
      final e = $24;
      Expression $$;
      $$ = _prefix(p, e, s);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $2;
  }

  Expression _parseSuffix(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    Expression $6;
    final $9 = _parsePrimary(false, $1);
    if (_success) {
      String $10;
      final $11 = _pos;
      for (;;) {
        String $14;
        final $17 = _parse_$QuestionMark(false, $1);
        if (_success) {
          $14 = $17;
          $10 = $14;
          break;
        }
        String $18;
        final $21 = _parse_$Asterisk(false, $1);
        if (_success) {
          $18 = $21;
          $10 = $18;
          break;
        }
        String $22;
        final $25 = _parse_$PlusSign(false, $1);
        if (_success) {
          $22 = $25;
          $10 = $22;
          break;
        }
        break;
      }
      if (!_success && _error == $11) {
        _fail(const ['\'?\'', '\'*\'', '\'+\'']);
      }
      final $26 = $10;
      _success = true;
      final e = $9;
      final s = $26;
      Expression $$;
      $$ = _suffix(s, e);
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $2;
  }

  Expression _parsePrimary(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      Expression $6;
      final $9 = _parse_sub_terminal_name(true, $1);
      if (_success) {
        final n = $9;
        Expression $$;
        $$ = SubterminalExpression(n);
        $6 = $$;
      }
      if (_success) {
        $2 = $6;
        break;
      }
      Expression $10;
      final $11 = _c;
      final $12 = _pos;
      _parse_$LeftParenthesis(true, false);
      if (_success) {
        final $14 = _parseExpression(true, $1);
        if (_success) {
          _parse_$RightParenthesis(false, false);
          if (_success) {
            $10 = $14;
          }
        }
        if (!_success) {
          _c = $11;
          _pos = $12;
        }
      }
      if (_success) {
        $2 = $10;
        break;
      }
      _c = $4;
      _pos = $3;
      Expression $16;
      final $19 = _parse_literal(false, $1);
      if (_success) {
        $16 = $19;
        $2 = $16;
        break;
      }
      Expression $20;
      final $23 = _parse_character_class(false, $1);
      if (_success) {
        $20 = $23;
        $2 = $20;
        break;
      }
      Expression $24;
      _parse_$Period(true, $1);
      if (_success) {
        Expression $$;
        $$ = AnyCharacterExpression();
        $24 = $$;
      }
      if (_success) {
        $2 = $24;
        break;
      }
      Expression $28;
      final $29 = _c;
      final $30 = _pos;
      _parse_$LessThanSign(true, false);
      if (_success) {
        final $32 = _parseExpression(true, $1);
        if (_success) {
          _parse_$GreaterThanSign(false, false);
          if (_success) {
            final e = $32;
            Expression $$;
            $$ = CaptureExpression(e);
            $28 = $$;
          }
        }
        if (!_success) {
          _c = $29;
          _pos = $30;
        }
      }
      if (_success) {
        $2 = $28;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $2;
  }

  ProductionRule _parseSubterminalDefinition(bool $0, bool $1) {
    ProductionRule $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      ProductionRule $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parseType(true, $1);
      if (_success) {
        final $10 = _parse_sub_terminal_name(true, $1);
        if (_success) {
          _parse_$EqualSign(true, false);
          if (_success) {
            final $12 = _parseExpression(true, $1);
            if (_success) {
              _parse_$Semicolon(false, false);
              if (_success) {
                final t = $9;
                final n = $10;
                final e = $12;
                ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, t);
                $6 = $$;
              }
            }
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      ProductionRule $14;
      final $15 = _c;
      final $16 = _pos;
      final $17 = _parse_sub_terminal_name(true, $1);
      if (_success) {
        _parse_$EqualSign(true, false);
        if (_success) {
          final $19 = _parseExpression(true, $1);
          if (_success) {
            _parse_$Semicolon(false, false);
            if (_success) {
              final n = $17;
              final e = $19;
              ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, null);
              $14 = $$;
            }
          }
        }
        if (!_success) {
          _c = $15;
          _pos = $16;
        }
      }
      if (_success) {
        $2 = $14;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    if (!_success && _error == $3) {
      _fail(const [
        '\'sub terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $2;
  }

  String _parseType(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(152)) {
      return _mresult as String;
    }
    final $5 = _pos;
    String $6;
    final $9 = _parseTypeName(false, $1);
    if (_success) {
      List<String> $10;
      final $11 = _pos;
      final $12 = _c;
      List<String> $14;
      _parse_$LessThanSign(false, false);
      if (_success) {
        final $18 = _parseTypeArguments(false, $1);
        if (_success) {
          _parse_$GreaterThanSign(false, false);
          if (_success) {
            $14 = $18;
          }
        }
        if (!_success) {
          _c = $12;
          _pos = $11;
        }
      }
      $10 = $14;
      if (!_success && _error == $11) {
        _fail(const ['\'<\'']);
      }
      final $20 = $10;
      _success = true;
      final n = $9;
      final a = $20;
      String $$;
      $$ = n + (a == null ? '' : '<' + a.join(', ') + '>');
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $5) {
      _fail(const ['\'library prefix\'', '\'type name\'']);
    }
    if ($0) {
      _memoize(152, $3, $2);
    }
    return $2;
  }

  String _parseTypeName(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      String $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parse_library_prefix(false, $1);
      if (_success) {
        _parse_$Period(true, false);
        if (_success) {
          final $11 = _parse_type_name(false, $1);
          if (_success) {
            final p = $9;
            final n = $11;
            String $$;
            $$ = '$p.$n';
            $6 = $$;
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      String $12;
      final $15 = _parse_type_name(false, $1);
      if (_success) {
        $12 = $15;
        $2 = $12;
        break;
      }
      break;
    }
    if (!_success && _error == $3) {
      _fail(const ['\'library prefix\'', '\'type name\'']);
    }
    return $2;
  }

  List<String> _parseTypeArguments(bool $0, bool $1) {
    List<String> $2;
    final $3 = _pos;
    List<String> $6;
    final $9 = _parseType(false, $1);
    if (_success) {
      List<String> $10;
      if ($1) {
        $10 = [];
      }
      for (;;) {
        String $11;
        final $12 = _pos;
        final $13 = _c;
        String $15;
        _parse_$Comma(false, false);
        if (_success) {
          final $19 = _parseType(false, $1);
          if (_success) {
            $15 = $19;
          } else {
            _c = $13;
            _pos = $12;
          }
        }
        $11 = $15;
        if (!_success && _error == $12) {
          _fail(const ['\',\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $10.add($11);
        }
      }
      final t = $9;
      final n = $10;
      List<String> $$;
      $$ = [t, ...n];
      $6 = $$;
    }
    $2 = $6;
    if (!_success && _error == $3) {
      _fail(const ['\'library prefix\'', '\'type name\'']);
    }
    return $2;
  }

  String _parse_non_terminal_name(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(176)) {
      return _mresult as String;
    }
    String $7;
    final $10 = _parse$$IDENTIFIER(false, $1);
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'non terminal name\'']);
    }
    if ($0) {
      _memoize(176, $3, $2);
    }
    return $2;
  }

  String _parse_terminal_name(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(180)) {
      return _mresult as String;
    }
    final $5 = _pos;
    String $7;
    String $10;
    final $12 = $1;
    $1 = false;
    final $14 = _pos;
    final $15 = _c;
    _matchChar(39);
    if (_success) {
      var $23 = false;
      for (;;) {
        final $25 = _pos;
        final $26 = _c;
        final $34 = _error;
        final $35 = _expected;
        final $36 = _failure;
        final $37 = $1;
        $1 = false;
        _matchChar(39);
        _success = !_success;
        _c = $26;
        _pos = $25;
        _error = $34;
        _expected = $35;
        _failure = $36;
        $1 = $37;
        if (_success) {
          _parse$$TERMINAL_CHAR(false, false);
          if (!_success) {
            _c = $26;
            _pos = $25;
          }
        }
        if (!_success) {
          _success = $23;
          break;
        }
        $23 = true;
      }
      if (_success) {
        _matchChar(39);
      }
      if (!_success) {
        _c = $15;
        _pos = $14;
      }
    }
    if (_success) {
      $10 = _text.substring($5, _pos);
    }
    $1 = $12;
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'terminal name\'']);
    }
    if ($0) {
      _memoize(180, $3, $2);
    }
    return $2;
  }

  String _parse_sub_terminal_name(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(194)) {
      return _mresult as String;
    }
    final $5 = _pos;
    String $7;
    String $10;
    final $12 = $1;
    $1 = false;
    final $14 = _pos;
    final $15 = _c;
    _matchChar(64);
    if (_success) {
      _parse$$IDENTIFIER(false, false);
      if (!_success) {
        _c = $15;
        _pos = $14;
      }
    }
    if (_success) {
      $10 = _text.substring($5, _pos);
    }
    $1 = $12;
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'sub terminal name\'']);
    }
    if ($0) {
      _memoize(194, $3, $2);
    }
    return $2;
  }

  String _parse_semantic_value(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    final $4 = _c;
    String $7;
    final $10 = _parse$$IDENTIFIER(true, $1);
    if (_success) {
      _matchString(':');
      if (_success) {
        $7 = $10;
      } else {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'semantic value\'']);
    }
    return $2;
  }

  String _parse_type_name(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $7;
    String $10;
    final $12 = $1;
    $1 = false;
    _parse$$IDENTIFIER(true, false);
    if (_success) {
      _matchChar(63);
      _success = true;
    }
    if (_success) {
      $10 = _text.substring($3, _pos);
    }
    $1 = $12;
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'type name\'']);
    }
    return $2;
  }

  String _parse_library_prefix(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    String $7;
    String $10;
    final $12 = $1;
    $1 = false;
    _matchChar(95);
    _parse$$IDENTIFIER(true, false);
    if (_success) {
      $10 = _text.substring($3, _pos);
    }
    $1 = $12;
    if (_success) {
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'library prefix\'']);
    }
    return $2;
  }

  String _parse_$Semicolon(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString(';');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\';\'']);
    }
    return $2;
  }

  String _parse_action(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    final $4 = _c;
    String $7;
    _matchString('{');
    if (_success) {
      String $11;
      final $12 = _pos;
      final $13 = $1;
      $1 = false;
      for (;;) {
        _parse$$ACTION_BODY(false, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
      if (_success) {
        $11 = _text.substring($12, _pos);
      }
      $1 = $13;
      _matchString('}');
      if (_success) {
        _parse$$SPACING(false, false);
        $7 = $11;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'action\'']);
    }
    return $2;
  }

  String _parse_$Ampersand(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('&');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'&\'']);
    }
    return $2;
  }

  Expression _parse_character_class(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    Expression $7;
    _matchString('[');
    if (_success) {
      List<List<int>> $11;
      if ($1) {
        $11 = [];
      }
      var $12 = false;
      for (;;) {
        List<int> $13;
        final $14 = _pos;
        final $15 = _c;
        List<int> $18;
        final $23 = _error;
        final $24 = _expected;
        final $25 = _failure;
        final $26 = $1;
        $1 = false;
        _matchString(']');
        _success = !_success;
        _c = $15;
        _pos = $14;
        _error = $23;
        _expected = $24;
        _failure = $25;
        $1 = $26;
        if (_success) {
          final $29 = _parse$$RANGE(false, $1);
          if (_success) {
            $18 = $29;
          } else {
            _c = $15;
            _pos = $14;
          }
        }
        $13 = $18;
        if (!_success) {
          _success = $12;
          if (!_success) {
            $11 = null;
          }
          break;
        }
        if ($1) {
          $11.add($13);
        }
        $12 = true;
      }
      if (_success) {
        _matchString(']');
        if (_success) {
          _parse$$SPACING(false, false);
          final r = $11;
          Expression $$;
          $$ = CharacterClassExpression(r);
          $7 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'character class\'']);
    }
    return $2;
  }

  String _parse_$RightParenthesis(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString(')');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\')\'']);
    }
    return $2;
  }

  String _parse_$Period(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(256)) {
      return _mresult as String;
    }
    String $7;
    final $10 = _matchString('.');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'.\'']);
    }
    if ($0) {
      _memoize(256, $3, $2);
    }
    return $2;
  }

  dynamic _parse_end_of_file(bool $0, bool $1) {
    dynamic $2;
    final $3 = _pos;
    final $4 = _c;
    dynamic $7;
    final $12 = _error;
    final $13 = _expected;
    final $14 = _failure;
    final $15 = $1;
    $1 = false;
    if (_c >= 0 && _c <= 1114111) {
      _success = true;
      _c = _input[_pos += _c <= 65535 ? 1 : 2];
    } else {
      _success = false;
      _failure = _pos;
    }
    _success = !_success;
    _c = $4;
    _pos = $3;
    _error = $12;
    _expected = $13;
    _failure = $14;
    $1 = $15;
    var $17;
    if (_success) {
      $7 = $17;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'end of file\'']);
    }
    return $2;
  }

  String _parse_globals(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    final $4 = _c;
    String $7;
    _matchString('%{');
    if (_success) {
      String $11;
      final $12 = _pos;
      final $13 = $1;
      $1 = false;
      for (;;) {
        _parse$$GLOBALS_BODY(false, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
      if (_success) {
        $11 = _text.substring($12, _pos);
      }
      $1 = $13;
      _matchString('}%');
      if (_success) {
        _parse$$SPACING(false, false);
        $7 = $11;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'globals\'']);
    }
    return $2;
  }

  List _parse_leading_spaces(bool $0, bool $1) {
    List $2;
    $2 = _parse$$SPACING(false, false);
    if (!_success && _error <= _failure) {
      _fail(const ['\'leading spaces\'']);
    }
    return $2;
  }

  String _parse_$EqualSign(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(277)) {
      return _mresult as String;
    }
    String $7;
    final $10 = _matchString('=');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'=\'']);
    }
    if ($0) {
      _memoize(277, $3, $2);
    }
    return $2;
  }

  Expression _parse_literal(bool $0, bool $1) {
    Expression $2;
    final $3 = _pos;
    final $4 = _c;
    Expression $7;
    _matchChar(34);
    if (_success) {
      List<int> $11;
      if ($1) {
        $11 = [];
      }
      for (;;) {
        int $12;
        final $13 = _pos;
        final $14 = _c;
        int $17;
        final $22 = _error;
        final $23 = _expected;
        final $24 = _failure;
        final $25 = $1;
        $1 = false;
        _matchChar(34);
        _success = !_success;
        _c = $14;
        _pos = $13;
        _error = $22;
        _expected = $23;
        _failure = $24;
        $1 = $25;
        if (_success) {
          final $28 = _parse$$LITERAL_CHAR(false, $1);
          if (_success) {
            $17 = $28;
          } else {
            _c = $14;
            _pos = $13;
          }
        }
        $12 = $17;
        if (!_success) {
          _success = true;
          break;
        }
        if ($1) {
          $11.add($12);
        }
      }
      _matchChar(34);
      if (_success) {
        _parse$$SPACING(false, false);
        final c = $11;
        Expression $$;
        $$ = LiteralExpression(String.fromCharCodes(c));
        $7 = $$;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'literal\'']);
    }
    return $2;
  }

  String _parse_members(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    final $4 = _c;
    String $7;
    _matchString('{');
    if (_success) {
      String $11;
      final $12 = _pos;
      final $13 = $1;
      $1 = false;
      for (;;) {
        _parse$$ACTION_BODY(false, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
      if (_success) {
        $11 = _text.substring($12, _pos);
      }
      $1 = $13;
      _matchString('}');
      if (_success) {
        _parse$$SPACING(false, false);
        $7 = $11;
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'members\'']);
    }
    return $2;
  }

  String _parse_$ExclamationMark(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('!');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'!\'']);
    }
    return $2;
  }

  String _parse_$LeftParenthesis(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(306)) {
      return _mresult as String;
    }
    String $7;
    final $10 = _matchString('(');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'(\'']);
    }
    if ($0) {
      _memoize(306, $3, $2);
    }
    return $2;
  }

  String _parse_$PlusSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('+');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'+\'']);
    }
    return $2;
  }

  String _parse_$Comma(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString(',');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\',\'']);
    }
    return $2;
  }

  String _parse_$QuestionMark(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('?');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'?\'']);
    }
    return $2;
  }

  String _parse_$Slash(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('/');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'/\'']);
    }
    return $2;
  }

  String _parse_$Asterisk(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('*');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'*\'']);
    }
    return $2;
  }

  String _parse_$LessThanSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('<');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'<\'']);
    }
    return $2;
  }

  String _parse_$GreaterThanSign(bool $0, bool $1) {
    String $2;
    String $7;
    final $10 = _matchString('>');
    if (_success) {
      _parse$$SPACING(false, false);
      $7 = $10;
    }
    $2 = $7;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>\'']);
    }
    return $2;
  }

  dynamic _parse$$ACTION_BODY(bool $0, bool $1) {
    dynamic $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      String $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _matchString('{');
      if (_success) {
        for (;;) {
          _parse$$ACTION_BODY(false, false);
          if (!_success) {
            _success = true;
            break;
          }
        }
        _matchString('}');
        if (_success) {
          $6 = $9;
        } else {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      dynamic $13;
      final $14 = _c;
      final $15 = _pos;
      final $18 = _error;
      final $19 = _expected;
      final $20 = _failure;
      final $21 = $1;
      $1 = false;
      _matchString('}');
      _success = !_success;
      _c = $14;
      _pos = $15;
      _error = $18;
      _expected = $19;
      _failure = $20;
      $1 = $21;
      var $23;
      if (_success) {
        if (_c >= 0 && _c <= 1114111) {
          _success = true;
          _c = _input[_pos += _c <= 65535 ? 1 : 2];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          $13 = $23;
        } else {
          _c = $14;
          _pos = $15;
        }
      }
      if (_success) {
        $2 = $13;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    return $2;
  }

  String _parse$$COMMENT(bool $0, bool $1) {
    String $2;
    String $6;
    final $9 = _matchString('#');
    if (_success) {
      for (;;) {
        final $12 = _pos;
        final $13 = _c;
        final $20 = _error;
        final $21 = _expected;
        final $22 = _failure;
        final $23 = $1;
        $1 = false;
        _parse$$EOL(false, false);
        _success = !_success;
        _c = $13;
        _pos = $12;
        _error = $20;
        _expected = $21;
        _failure = $22;
        $1 = $23;
        if (_success) {
          if (_c >= 0 && _c <= 1114111) {
            _success = true;
            _c = _input[_pos += _c <= 65535 ? 1 : 2];
          } else {
            _success = false;
            _failure = _pos;
          }
          if (!_success) {
            _c = $13;
            _pos = $12;
          }
        }
        if (!_success) {
          _success = true;
          break;
        }
      }
      _parse$$EOL(false, false);
      _success = true;
      $6 = $9;
    }
    $2 = $6;
    return $2;
  }

  dynamic _parse$$EOL(bool $0, bool $1) {
    dynamic $2;
    for (;;) {
      String $6;
      final $9 = _matchString('\r\n');
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      int $10;
      const $13 = [10, 10, 13, 13];
      final $14 = _matchRanges($13);
      if (_success) {
        $10 = $14;
        $2 = $10;
        break;
      }
      break;
    }
    return $2;
  }

  dynamic _parse$$GLOBALS_BODY(bool $0, bool $1) {
    dynamic $2;
    final $3 = _pos;
    final $4 = _c;
    dynamic $6;
    final $11 = _error;
    final $12 = _expected;
    final $13 = _failure;
    final $14 = $1;
    $1 = false;
    _matchString('}%');
    _success = !_success;
    _c = $4;
    _pos = $3;
    _error = $11;
    _expected = $12;
    _failure = $13;
    $1 = $14;
    var $16;
    if (_success) {
      if (_c >= 0 && _c <= 1114111) {
        _success = true;
        _c = _input[_pos += _c <= 65535 ? 1 : 2];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $6 = $16;
      } else {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    return $2;
  }

  int _parse$$HEX_NUMBER(bool $0, bool $1) {
    int $2;
    final $3 = _pos;
    final $4 = _c;
    int $6;
    _matchChar(92);
    if (_success) {
      _matchString('u');
      if (_success) {
        String $11;
        final $12 = _pos;
        final $13 = $1;
        $1 = false;
        var $22 = false;
        for (;;) {
          const $23 = [48, 57, 65, 70, 97, 102];
          _matchRanges($23);
          if (!_success) {
            _success = $22;
            break;
          }
          $22 = true;
        }
        if (_success) {
          $11 = _text.substring($12, _pos);
        }
        $1 = $13;
        if (_success) {
          final d = $11;
          int $$;
          $$ = int.parse(d, radix: 16);
          $6 = $$;
        }
      }
      if (!_success) {
        _c = $4;
        _pos = $3;
      }
    }
    $2 = $6;
    return $2;
  }

  String _parse$$IDENTIFIER(bool $0, bool $1) {
    String $2;
    final $3 = _pos;
    if ($0 && _memoized(378)) {
      return _mresult as String;
    }
    final $5 = _pos;
    String $6;
    String $9;
    final $11 = $1;
    $1 = false;
    _parse$$IDENT_START(false, false);
    if (_success) {
      for (;;) {
        _parse$$IDENT_CONT(false, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
    }
    if (_success) {
      $9 = _text.substring($5, _pos);
    }
    $1 = $11;
    if (_success) {
      $6 = $9;
    }
    $2 = $6;
    if ($0) {
      _memoize(378, $3, $2);
    }
    return $2;
  }

  int _parse$$IDENT_CONT(bool $0, bool $1) {
    int $2;
    for (;;) {
      int $6;
      final $9 = _parse$$IDENT_START(true, false);
      if (_success) {
        $6 = $9;
        $2 = $6;
        break;
      }
      int $10;
      const $13 = [48, 57, 95, 95];
      final $14 = _matchRanges($13);
      if (_success) {
        $10 = $14;
        $2 = $10;
        break;
      }
      break;
    }
    return $2;
  }

  int _parse$$IDENT_START(bool $0, bool $1) {
    int $2;
    int $6;
    const $9 = [65, 90, 97, 122];
    final $10 = _matchRanges($9);
    if (_success) {
      $6 = $10;
    }
    $2 = $6;
    return $2;
  }

  int _parse$$LITERAL_CHAR(bool $0, bool $1) {
    int $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      int $6;
      final $7 = _c;
      final $8 = _pos;
      _matchString('\\');
      if (_success) {
        const $10 = [34, 34, 92, 92, 110, 110, 114, 114, 116, 116];
        final $11 = _matchRanges($10);
        if (_success) {
          final c = $11;
          int $$;
          $$ = _escape(c);
          $6 = $$;
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      int $12;
      final $15 = _parse$$HEX_NUMBER(false, $1);
      if (_success) {
        $12 = $15;
        $2 = $12;
        break;
      }
      int $16;
      final $17 = _c;
      final $18 = _pos;
      final $21 = _error;
      final $22 = _expected;
      final $23 = _failure;
      final $24 = $1;
      $1 = false;
      _matchString('\\');
      _success = !_success;
      _c = $17;
      _pos = $18;
      _error = $21;
      _expected = $22;
      _failure = $23;
      $1 = $24;
      if (_success) {
        final $27 = _c;
        final $28 = _pos;
        final $29 = _error;
        final $30 = _expected;
        final $31 = _failure;
        final $32 = $1;
        $1 = false;
        _parse$$EOL(false, false);
        _success = !_success;
        _c = $27;
        _pos = $28;
        _error = $29;
        _expected = $30;
        _failure = $31;
        $1 = $32;
        if (_success) {
          int $35;
          if (_c >= 0 && _c <= 1114111) {
            _success = true;
            $35 = _c;
            _c = _input[_pos += _c <= 65535 ? 1 : 2];
          } else {
            _success = false;
            _failure = _pos;
          }
          if (_success) {
            $16 = $35;
          }
        }
        if (!_success) {
          _c = $17;
          _pos = $18;
        }
      }
      if (_success) {
        $2 = $16;
        break;
      }
      _c = $4;
      _pos = $3;
      break;
    }
    return $2;
  }

  List<int> _parse$$RANGE(bool $0, bool $1) {
    List<int> $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      List<int> $6;
      final $7 = _c;
      final $8 = _pos;
      final $9 = _parse$$RANGE_CHAR(true, $1);
      if (_success) {
        _matchString('-');
        if (_success) {
          final $11 = _parse$$RANGE_CHAR(false, $1);
          if (_success) {
            final s = $9;
            final e = $11;
            List<int> $$;
            $$ = [s, e];
            $6 = $$;
          }
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      List<int> $12;
      final $15 = _parse$$RANGE_CHAR(true, $1);
      if (_success) {
        final c = $15;
        List<int> $$;
        $$ = [c, c];
        $12 = $$;
      }
      if (_success) {
        $2 = $12;
        break;
      }
      break;
    }
    return $2;
  }

  int _parse$$RANGE_CHAR(bool $0, bool $1) {
    int $2;
    final $3 = _pos;
    if ($0 && _memoized(413)) {
      return _mresult as int;
    }
    final $4 = _c;
    final $5 = _pos;
    for (;;) {
      int $6;
      final $7 = _c;
      final $8 = _pos;
      _matchString('\\');
      if (_success) {
        const $10 = [92, 93, 110, 110, 114, 114, 116, 116];
        final $11 = _matchRanges($10);
        if (_success) {
          final c = $11;
          int $$;
          $$ = _escape(c);
          $6 = $$;
        }
        if (!_success) {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $5;
      int $12;
      final $15 = _parse$$HEX_NUMBER(false, $1);
      if (_success) {
        $12 = $15;
        $2 = $12;
        break;
      }
      int $16;
      final $17 = _c;
      final $18 = _pos;
      final $21 = _error;
      final $22 = _expected;
      final $23 = _failure;
      final $24 = $1;
      $1 = false;
      const $25 = [92, 93];
      _matchRanges($25);
      _success = !_success;
      _c = $17;
      _pos = $18;
      _error = $21;
      _expected = $22;
      _failure = $23;
      $1 = $24;
      if (_success) {
        final $28 = _c;
        final $29 = _pos;
        final $30 = _error;
        final $31 = _expected;
        final $32 = _failure;
        final $33 = $1;
        $1 = false;
        _parse$$EOL(false, false);
        _success = !_success;
        _c = $28;
        _pos = $29;
        _error = $30;
        _expected = $31;
        _failure = $32;
        $1 = $33;
        if (_success) {
          int $36;
          if (_c >= 0 && _c <= 1114111) {
            _success = true;
            $36 = _c;
            _c = _input[_pos += _c <= 65535 ? 1 : 2];
          } else {
            _success = false;
            _failure = _pos;
          }
          if (_success) {
            $16 = $36;
          }
        }
        if (!_success) {
          _c = $17;
          _pos = $18;
        }
      }
      if (_success) {
        $2 = $16;
        break;
      }
      _c = $4;
      _pos = $5;
      break;
    }
    if ($0) {
      _memoize(413, $3, $2);
    }
    return $2;
  }

  dynamic _parse$$SPACE(bool $0, bool $1) {
    dynamic $2;
    for (;;) {
      int $6;
      const $9 = [9, 9, 32, 32];
      final $10 = _matchRanges($9);
      if (_success) {
        $6 = $10;
        $2 = $6;
        break;
      }
      dynamic $11;
      final $14 = _parse$$EOL(false, false);
      if (_success) {
        $11 = $14;
        $2 = $11;
        break;
      }
      break;
    }
    return $2;
  }

  List _parse$$SPACING(bool $0, bool $1) {
    List $2;
    for (;;) {
      for (;;) {
        _parse$$SPACE(false, false);
        if (_success) {
          break;
        }
        _parse$$COMMENT(false, false);
        if (_success) {
          break;
        }
        break;
      }
      if (!_success) {
        _success = true;
        break;
      }
    }
    return $2;
  }

  int _parse$$TERMINAL_CHAR(bool $0, bool $1) {
    int $2;
    final $3 = _pos;
    final $4 = _c;
    for (;;) {
      int $6;
      final $7 = _c;
      final $8 = _pos;
      _matchString('//');
      if (_success) {
        final $10 = _matchChar(39);
        if (_success) {
          $6 = $10;
        } else {
          _c = $7;
          _pos = $8;
        }
      }
      if (_success) {
        $2 = $6;
        break;
      }
      _c = $4;
      _pos = $3;
      int $11;
      const $14 = [32, 38, 40, 126];
      final $15 = _matchRanges($14);
      if (_success) {
        $11 = $15;
        $2 = $11;
        break;
      }
      break;
    }
    return $2;
  }
}

class _Memo {
  final int id;

  final int pos;

  final result;

  final bool success;

  _Memo({
    this.id,
    this.pos,
    this.result,
    this.success,
  });
}

// ignore_for_file: unused_element
// ignore_for_file: unused_field
