// Generated by 'peg2'
// https://pub.dev/packages/peg2

import 'package:peg2/grammar.dart';
import 'package:peg2/expressions.dart';

int _escape(int c) {
  switch (c) {
    case 110:
      return 0xA;
    case 114:
      return 0xD;
    case 116:
      return 0x9;
  }

  return c;
}

Expression _prefix(String? prefix, Expression expression, String? variable) {
  switch (prefix) {
    case '&':
      expression = AndPredicateExpression(expression);
      break;
    case '!':
      expression = NotPredicateExpression(expression);
      break;
  }

  expression.variable = variable;
  return expression;
}

Expression _suffix(String? suffix, Expression expression) {
  switch (suffix) {
    case '?':
      return OptionalExpression(expression);
    case '*':
      return ZeroOrMoreExpression(expression);
    case '+':
      return OneOrMoreExpression(expression);
  }

  return expression;
}

class Peg2Parser {
  static const int _eof = 1114112;

  FormatException? error;

  int _failStart = -1;

  List _failures = [];

  bool ok = false;

  int _ch = 0;

  int _failPos = -1;

  int _pos = 0;

  String _source = '';

  Grammar? parse(String source) {
    _source = source;
    _reset();
    final result = parseGrammar();
    if (!ok) {
      _buildError();
    }

    return result;
  }

  Grammar? parseGrammar() {
    Grammar? $0;
    final $1 = _ch;
    final $2 = _pos;
    Grammar? $3;
    parse_leading_spaces();
    ok = true;
    final $5 = parse_globals();
    final $4 = $5;
    ok = true;
    final $7 = parse_members();
    final $6 = $7;
    ok = true;
    final $8 = <ProductionRule>[];
    while (true) {
      final $9 = parseDefinition();
      if (!ok) {
        break;
      }
      $8.add($9!);
    }
    ok = $8.isNotEmpty;
    if (ok) {
      parse_end_of_file();
      if (ok) {
        final g = $4;
        final m = $6;
        final d = $8;
        late Grammar $$;
        $$ = Grammar(d, g, m);
        $3 = $$;
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  ProductionRule? parseDefinition() {
    ProductionRule? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      ProductionRule? $3;
      final $4 = parseNonterminalDefinition();
      if (ok) {
        $3 = $4;
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      ProductionRule? $5;
      final $6 = parseTerminalDefinition();
      if (ok) {
        $5 = $6;
      }
      if (ok) {
        $0 = $5;
        break;
      }
      _pos = $2;
      _ch = $1;
      ProductionRule? $7;
      final $8 = parseSubterminalDefinition();
      if (ok) {
        $7 = $8;
      }
      if (ok) {
        $0 = $7;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  ProductionRule? parseNonterminalDefinition() {
    ProductionRule? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      ProductionRule? $3;
      final $4 = parseType();
      if (ok) {
        final $5 = parse_non_terminal_name();
        if (ok) {
          parse_$EqualSign();
          if (ok) {
            final $6 = parseNonterminalExpression();
            if (ok) {
              parse_$Semicolon();
              if (ok) {
                final t = $4!;
                final n = $5!;
                final e = $6!;
                late ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, t);
                $3 = $$;
              }
            }
          }
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      ProductionRule? $7;
      final $8 = parse_non_terminal_name();
      if (ok) {
        parse_$EqualSign();
        if (ok) {
          final $9 = parseNonterminalExpression();
          if (ok) {
            parse_$Semicolon();
            if (ok) {
              final n = $8!;
              final e = $9!;
              late ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, null);
              $7 = $$;
            }
          }
        }
      }
      if (ok) {
        $0 = $7;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  OrderedChoiceExpression? parseNonterminalExpression() {
    OrderedChoiceExpression? $0;
    final $1 = _ch;
    final $2 = _pos;
    OrderedChoiceExpression? $3;
    final $4 = parseNonterminalSequence();
    if (ok) {
      final $5 = <SequenceExpression>[];
      while (true) {
        SequenceExpression? $6;
        final $7 = _ch;
        final $8 = _pos;
        SequenceExpression? $9;
        parse_$Slash();
        if (ok) {
          final $10 = parseNonterminalSequence();
          if (ok) {
            $9 = $10;
          }
        }
        if (ok) {
          $6 = $9;
        } else {
          _pos = $8;
          _ch = $7;
          break;
        }
        $5.add($6!);
      }
      ok = true;
      final e = $4!;
      final n = $5;
      late OrderedChoiceExpression $$;
      $$ = OrderedChoiceExpression([e, ...n]);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  SequenceExpression? parseNonterminalSequence() {
    SequenceExpression? $0;
    final $1 = _ch;
    final $2 = _pos;
    SequenceExpression? $3;
    final $4 = <Expression>[];
    while (true) {
      final $5 = parseNonterminalPrefix();
      if (!ok) {
        break;
      }
      $4.add($5!);
    }
    ok = $4.isNotEmpty;
    if (ok) {
      final $7 = parse_action();
      final $6 = $7;
      ok = true;
      final e = $4;
      final a = $6;
      late SequenceExpression $$;
      $$ = SequenceExpression(e, a);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  Expression? parseNonterminalPrefix() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    Expression? $3;
    final $5 = parse_semantic_value();
    final $4 = $5;
    ok = true;
    String? $7;
    final $8 = _ch;
    final $9 = _pos;
    while (true) {
      String? $10;
      final $11 = parse_$Ampersand();
      if (ok) {
        $10 = $11;
      }
      if (ok) {
        $7 = $10;
        break;
      }
      _pos = $9;
      _ch = $8;
      String? $12;
      final $13 = parse_$ExclamationMark();
      if (ok) {
        $12 = $13;
      }
      if (ok) {
        $7 = $12;
        break;
      }
      _pos = $9;
      _ch = $8;
      break;
    }
    final $6 = $7;
    ok = true;
    final $14 = parseNonterminalSuffix();
    if (ok) {
      final s = $4;
      final p = $6;
      final e = $14!;
      late Expression $$;
      $$ = _prefix(p, e, s);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  Expression? parseNonterminalSuffix() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    Expression? $3;
    final $4 = parseNonterminalPrimary();
    if (ok) {
      String? $6;
      final $7 = _ch;
      final $8 = _pos;
      while (true) {
        String? $9;
        final $10 = parse_$QuestionMark();
        if (ok) {
          $9 = $10;
        }
        if (ok) {
          $6 = $9;
          break;
        }
        _pos = $8;
        _ch = $7;
        String? $11;
        final $12 = parse_$Asterisk();
        if (ok) {
          $11 = $12;
        }
        if (ok) {
          $6 = $11;
          break;
        }
        _pos = $8;
        _ch = $7;
        String? $13;
        final $14 = parse_$PlusSign();
        if (ok) {
          $13 = $14;
        }
        if (ok) {
          $6 = $13;
          break;
        }
        _pos = $8;
        _ch = $7;
        break;
      }
      final $5 = $6;
      ok = true;
      final e = $4!;
      final s = $5;
      late Expression $$;
      $$ = _suffix(s, e);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  Expression? parseNonterminalPrimary() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      Expression? $3;
      final $4 = parse_non_terminal_name();
      if (ok) {
        final n = $4!;
        late Expression $$;
        $$ = NonterminalExpression(n);
        $3 = $$;
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      Expression? $5;
      final $6 = parse_terminal_name();
      if (ok) {
        final n = $6!;
        late Expression $$;
        $$ = TerminalExpression(n);
        $5 = $$;
      }
      if (ok) {
        $0 = $5;
        break;
      }
      _pos = $2;
      _ch = $1;
      Expression? $7;
      parse_$LeftParenthesis();
      if (ok) {
        final $8 = parseNonterminalExpression();
        if (ok) {
          parse_$RightParenthesis();
          if (ok) {
            $7 = $8;
          }
        }
      }
      if (ok) {
        $0 = $7;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  ProductionRule? parseTerminalDefinition() {
    ProductionRule? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      ProductionRule? $3;
      final $4 = parseType();
      if (ok) {
        final $5 = parse_terminal_name();
        if (ok) {
          parse_$EqualSign();
          if (ok) {
            final $6 = parseExpression();
            if (ok) {
              parse_$Semicolon();
              if (ok) {
                final t = $4!;
                final n = $5!;
                final e = $6!;
                late ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.terminal, e, t);
                $3 = $$;
              }
            }
          }
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      ProductionRule? $7;
      final $8 = parse_terminal_name();
      if (ok) {
        parse_$EqualSign();
        if (ok) {
          final $9 = parseExpression();
          if (ok) {
            parse_$Semicolon();
            if (ok) {
              final n = $8!;
              final e = $9!;
              late ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.terminal, e, null);
              $7 = $$;
            }
          }
        }
      }
      if (ok) {
        $0 = $7;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  OrderedChoiceExpression? parseExpression() {
    OrderedChoiceExpression? $0;
    final $1 = _ch;
    final $2 = _pos;
    OrderedChoiceExpression? $3;
    final $4 = parseSequence();
    if (ok) {
      final $5 = <SequenceExpression>[];
      while (true) {
        SequenceExpression? $6;
        final $7 = _ch;
        final $8 = _pos;
        SequenceExpression? $9;
        parse_$Slash();
        if (ok) {
          final $10 = parseSequence();
          if (ok) {
            $9 = $10;
          }
        }
        if (ok) {
          $6 = $9;
        } else {
          _pos = $8;
          _ch = $7;
          break;
        }
        $5.add($6!);
      }
      ok = true;
      final e = $4!;
      final n = $5;
      late OrderedChoiceExpression $$;
      $$ = OrderedChoiceExpression([e, ...n]);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  SequenceExpression? parseSequence() {
    SequenceExpression? $0;
    final $1 = _ch;
    final $2 = _pos;
    SequenceExpression? $3;
    final $4 = <Expression>[];
    while (true) {
      final $5 = parsePrefix();
      if (!ok) {
        break;
      }
      $4.add($5!);
    }
    ok = $4.isNotEmpty;
    if (ok) {
      final $7 = parse_action();
      final $6 = $7;
      ok = true;
      final e = $4;
      final a = $6;
      late SequenceExpression $$;
      $$ = SequenceExpression(e, a);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  Expression? parsePrefix() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    Expression? $3;
    final $5 = parse_semantic_value();
    final $4 = $5;
    ok = true;
    String? $7;
    final $8 = _ch;
    final $9 = _pos;
    while (true) {
      String? $10;
      final $11 = parse_$Ampersand();
      if (ok) {
        $10 = $11;
      }
      if (ok) {
        $7 = $10;
        break;
      }
      _pos = $9;
      _ch = $8;
      String? $12;
      final $13 = parse_$ExclamationMark();
      if (ok) {
        $12 = $13;
      }
      if (ok) {
        $7 = $12;
        break;
      }
      _pos = $9;
      _ch = $8;
      break;
    }
    final $6 = $7;
    ok = true;
    final $14 = parseSuffix();
    if (ok) {
      final s = $4;
      final p = $6;
      final e = $14!;
      late Expression $$;
      $$ = _prefix(p, e, s);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  Expression? parseSuffix() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    Expression? $3;
    final $4 = parsePrimary();
    if (ok) {
      String? $6;
      final $7 = _ch;
      final $8 = _pos;
      while (true) {
        String? $9;
        final $10 = parse_$QuestionMark();
        if (ok) {
          $9 = $10;
        }
        if (ok) {
          $6 = $9;
          break;
        }
        _pos = $8;
        _ch = $7;
        String? $11;
        final $12 = parse_$Asterisk();
        if (ok) {
          $11 = $12;
        }
        if (ok) {
          $6 = $11;
          break;
        }
        _pos = $8;
        _ch = $7;
        String? $13;
        final $14 = parse_$PlusSign();
        if (ok) {
          $13 = $14;
        }
        if (ok) {
          $6 = $13;
          break;
        }
        _pos = $8;
        _ch = $7;
        break;
      }
      final $5 = $6;
      ok = true;
      final e = $4!;
      final s = $5;
      late Expression $$;
      $$ = _suffix(s, e);
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  Expression? parsePrimary() {
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      Expression? $3;
      final $4 = parse_sub_terminal_name();
      if (ok) {
        final n = $4!;
        late Expression $$;
        $$ = SubterminalExpression(n);
        $3 = $$;
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      Expression? $5;
      parse_$LeftParenthesis();
      if (ok) {
        final $6 = parseExpression();
        if (ok) {
          parse_$RightParenthesis();
          if (ok) {
            $5 = $6;
          }
        }
      }
      if (ok) {
        $0 = $5;
        break;
      }
      _pos = $2;
      _ch = $1;
      Expression? $7;
      final $8 = parse_literal();
      if (ok) {
        $7 = $8;
      }
      if (ok) {
        $0 = $7;
        break;
      }
      _pos = $2;
      _ch = $1;
      Expression? $9;
      final $10 = parse_character_class();
      if (ok) {
        $9 = $10;
      }
      if (ok) {
        $0 = $9;
        break;
      }
      _pos = $2;
      _ch = $1;
      Expression? $11;
      parse_$Period();
      if (ok) {
        late Expression $$;
        $$ = AnyCharacterExpression();
        $11 = $$;
      }
      if (ok) {
        $0 = $11;
        break;
      }
      _pos = $2;
      _ch = $1;
      Expression? $12;
      parse_$LessThanSign();
      if (ok) {
        final $13 = parseExpression();
        if (ok) {
          parse_$GreaterThanSign();
          if (ok) {
            final e = $13!;
            late Expression $$;
            $$ = CaptureExpression(e);
            $12 = $$;
          }
        }
      }
      if (ok) {
        $0 = $12;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  ProductionRule? parseSubterminalDefinition() {
    ProductionRule? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      ProductionRule? $3;
      final $4 = parseType();
      if (ok) {
        final $5 = parse_sub_terminal_name();
        if (ok) {
          parse_$EqualSign();
          if (ok) {
            final $6 = parseExpression();
            if (ok) {
              parse_$Semicolon();
              if (ok) {
                final t = $4!;
                final n = $5!;
                final e = $6!;
                late ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, t);
                $3 = $$;
              }
            }
          }
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      ProductionRule? $7;
      final $8 = parse_sub_terminal_name();
      if (ok) {
        parse_$EqualSign();
        if (ok) {
          final $9 = parseExpression();
          if (ok) {
            parse_$Semicolon();
            if (ok) {
              final n = $8!;
              final e = $9!;
              late ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, null);
              $7 = $$;
            }
          }
        }
      }
      if (ok) {
        $0 = $7;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  String? parseType() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = parseTypeName();
    if (ok) {
      List<String>? $6;
      final $7 = _ch;
      final $8 = _pos;
      List<String>? $9;
      parse_$LessThanSign();
      if (ok) {
        final $10 = parseTypeArguments();
        if (ok) {
          parse_$GreaterThanSign();
          if (ok) {
            $9 = $10;
          }
        }
      }
      if (ok) {
        $6 = $9;
      } else {
        _pos = $8;
        _ch = $7;
      }
      final $5 = $6;
      ok = true;
      final n = $4!;
      final a = $5;
      late String $$;
      $$ = n + (a == null ? '' : '<' + a.join(', ') + '>');
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  String? parseTypeName() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      String? $3;
      final $4 = parse_library_prefix();
      if (ok) {
        parse_$Period();
        if (ok) {
          final $5 = parse_type_name();
          if (ok) {
            final p = $4!;
            final n = $5!;
            late String $$;
            $$ = '$p.$n';
            $3 = $$;
          }
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      String? $6;
      final $7 = parse_type_name();
      if (ok) {
        $6 = $7;
      }
      if (ok) {
        $0 = $6;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  List<String>? parseTypeArguments() {
    List<String>? $0;
    final $1 = _ch;
    final $2 = _pos;
    List<String>? $3;
    final $4 = parseType();
    if (ok) {
      final $5 = <String>[];
      while (true) {
        String? $6;
        final $7 = _ch;
        final $8 = _pos;
        String? $9;
        parse_$Comma();
        if (ok) {
          final $10 = parseType();
          if (ok) {
            $9 = $10;
          }
        }
        if (ok) {
          $6 = $9;
        } else {
          _pos = $8;
          _ch = $7;
          break;
        }
        $5.add($6!);
      }
      ok = true;
      final t = $4!;
      final n = $5;
      late List<String> $$;
      $$ = [t, ...n];
      $3 = $$;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  String? parse_non_terminal_name() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = parse$$IDENTIFIER();
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'non terminal name\'');
    }
    return $0;
  }

  String? parse_terminal_name() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    String? $4;
    final $5 = _pos;
    final $6 = _ch;
    final $7 = _pos;
    _matchChar(39, 39);
    if (ok) {
      var $8 = 0;
      while (true) {
        final $9 = _ch;
        final $10 = _pos;
        final $11 = _ch;
        final $12 = _pos;
        _matchChar(39, 39);
        _ch = $11;
        _pos = $12;
        ok = !ok;
        if (ok) {
          parse$$TERMINAL_CHAR();
        }
        if (!ok) {
          _pos = $10;
          _ch = $9;
        }
        if (!ok) {
          break;
        }
        $8++;
      }
      ok = $8 != 0;
      if (ok) {
        _matchChar(39, 39);
      }
    }
    if (!ok) {
      _pos = $7;
      _ch = $6;
    }
    if (ok) {
      $4 = _source.substring($5, _pos);
    }
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'terminal name\'');
    }
    return $0;
  }

  String? parse_sub_terminal_name() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    String? $4;
    final $5 = _pos;
    final $6 = _ch;
    final $7 = _pos;
    _matchChar(64, 64);
    if (ok) {
      parse$$IDENTIFIER();
    }
    if (!ok) {
      _pos = $7;
      _ch = $6;
    }
    if (ok) {
      $4 = _source.substring($5, _pos);
    }
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'sub terminal name\'');
    }
    return $0;
  }

  String? parse_semantic_value() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = parse$$IDENTIFIER();
    if (ok) {
      _matchChar(58, ':');
      if (ok) {
        $3 = $4;
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'semantic value\'');
    }
    return $0;
  }

  String? parse_type_name() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    String? $4;
    final $5 = _pos;
    final $6 = _ch;
    final $7 = _pos;
    parse$$IDENTIFIER();
    if (ok) {
      _matchChar(63, 63);
      ok = true;
    }
    if (!ok) {
      _pos = $7;
      _ch = $6;
    }
    if (ok) {
      $4 = _source.substring($5, _pos);
    }
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'type name\'');
    }
    return $0;
  }

  String? parse_library_prefix() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    String? $4;
    final $5 = _pos;
    final $6 = _ch;
    final $7 = _pos;
    _matchChar(95, 95);
    ok = true;
    parse$$IDENTIFIER();
    if (!ok) {
      _pos = $7;
      _ch = $6;
    }
    if (ok) {
      $4 = _source.substring($5, _pos);
    }
    if (ok) {
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'library prefix\'');
    }
    return $0;
  }

  String? parse_$Semicolon() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(59, ';');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\';\'');
    }
    return $0;
  }

  String? parse_action() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    _matchChar(123, '{');
    if (ok) {
      String? $4;
      final $5 = _pos;
      final $6 = _ch;
      final $7 = _pos;
      while (true) {
        parse$$ACTION_BODY();
        if (!ok) {
          break;
        }
      }
      ok = true;
      if (!ok) {
        _pos = $7;
        _ch = $6;
      }
      if (ok) {
        $4 = _source.substring($5, _pos);
      }
      _matchChar(125, '}');
      if (ok) {
        parse$$SPACING();
        $3 = $4;
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'action\'');
    }
    return $0;
  }

  String? parse_$Ampersand() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(38, '&');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'&\'');
    }
    return $0;
  }

  Expression? parse_character_class() {
    _failPos = -1;
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    Expression? $3;
    _matchChar(91, '[');
    if (ok) {
      final $4 = <List<int>>[];
      while (true) {
        List<int>? $5;
        final $6 = _ch;
        final $7 = _pos;
        List<int>? $8;
        final $9 = _ch;
        final $10 = _pos;
        _matchChar(93, ']');
        _ch = $9;
        _pos = $10;
        ok = !ok;
        if (ok) {
          final $11 = parse$$RANGE();
          if (ok) {
            $8 = $11;
          }
        }
        if (ok) {
          $5 = $8;
        } else {
          _pos = $7;
          _ch = $6;
        }
        if (!ok) {
          break;
        }
        $4.add($5!);
      }
      ok = $4.isNotEmpty;
      if (ok) {
        _matchChar(93, ']');
        if (ok) {
          parse$$SPACING();
          final r = $4;
          late Expression $$;
          $$ = CharacterClassExpression(r);
          $3 = $$;
        }
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'character class\'');
    }
    return $0;
  }

  String? parse_$RightParenthesis() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(41, ')');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\')\'');
    }
    return $0;
  }

  String? parse_$Period() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(46, '.');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'.\'');
    }
    return $0;
  }

  dynamic? parse_end_of_file() {
    _failPos = -1;
    dynamic? $0;
    final $1 = _ch;
    final $2 = _pos;
    dynamic? $3;
    final $5 = _ch;
    final $6 = _pos;
    _matchAny();
    final $4 = null;
    _ch = $5;
    _pos = $6;
    ok = !ok;
    if (ok) {
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'end of file\'');
    }
    return $0;
  }

  String? parse_globals() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    _matchString('%{');
    if (ok) {
      String? $4;
      final $5 = _pos;
      final $6 = _ch;
      final $7 = _pos;
      while (true) {
        parse$$GLOBALS_BODY();
        if (!ok) {
          break;
        }
      }
      ok = true;
      if (!ok) {
        _pos = $7;
        _ch = $6;
      }
      if (ok) {
        $4 = _source.substring($5, _pos);
      }
      _matchString('}%');
      if (ok) {
        parse$$SPACING();
        $3 = $4;
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'globals\'');
    }
    return $0;
  }

  List? parse_leading_spaces() {
    _failPos = -1;
    List? $0;
    final $1 = _ch;
    final $2 = _pos;
    List? $3;
    final $4 = parse$$SPACING();
    $3 = $4;
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'leading spaces\'');
    }
    return $0;
  }

  String? parse_$EqualSign() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(61, '=');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'=\'');
    }
    return $0;
  }

  Expression? parse_literal() {
    _failPos = -1;
    Expression? $0;
    final $1 = _ch;
    final $2 = _pos;
    Expression? $3;
    _matchChar(34, 34);
    if (ok) {
      final $4 = <int>[];
      while (true) {
        int? $5;
        final $6 = _ch;
        final $7 = _pos;
        int? $8;
        final $9 = _ch;
        final $10 = _pos;
        _matchChar(34, 34);
        _ch = $9;
        _pos = $10;
        ok = !ok;
        if (ok) {
          final $11 = parse$$LITERAL_CHAR();
          if (ok) {
            $8 = $11;
          }
        }
        if (ok) {
          $5 = $8;
        } else {
          _pos = $7;
          _ch = $6;
          break;
        }
        $4.add($5!);
      }
      ok = true;
      _matchChar(34, 34);
      if (ok) {
        parse$$SPACING();
        final c = $4;
        late Expression $$;
        $$ = LiteralExpression(String.fromCharCodes(c));
        $3 = $$;
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'literal\'');
    }
    return $0;
  }

  String? parse_members() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    _matchChar(123, '{');
    if (ok) {
      String? $4;
      final $5 = _pos;
      final $6 = _ch;
      final $7 = _pos;
      while (true) {
        parse$$ACTION_BODY();
        if (!ok) {
          break;
        }
      }
      ok = true;
      if (!ok) {
        _pos = $7;
        _ch = $6;
      }
      if (ok) {
        $4 = _source.substring($5, _pos);
      }
      _matchChar(125, '}');
      if (ok) {
        parse$$SPACING();
        $3 = $4;
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'members\'');
    }
    return $0;
  }

  String? parse_$ExclamationMark() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(33, '!');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'!\'');
    }
    return $0;
  }

  String? parse_$LeftParenthesis() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(40, '(');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'(\'');
    }
    return $0;
  }

  String? parse_$PlusSign() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(43, '+');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'+\'');
    }
    return $0;
  }

  String? parse_$Comma() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(44, ',');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\',\'');
    }
    return $0;
  }

  String? parse_$QuestionMark() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(63, '?');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'?\'');
    }
    return $0;
  }

  String? parse_$Slash() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(47, '/');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'/\'');
    }
    return $0;
  }

  String? parse_$Asterisk() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(42, '*');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'*\'');
    }
    return $0;
  }

  String? parse_$LessThanSign() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(60, '<');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'<\'');
    }
    return $0;
  }

  String? parse_$GreaterThanSign() {
    _failPos = -1;
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(62, '>');
    if (ok) {
      parse$$SPACING();
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
      _fail('\'>\'');
    }
    return $0;
  }

  dynamic? parse$$ACTION_BODY() {
    dynamic? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      String? $3;
      final $4 = _matchChar(123, '{');
      if (ok) {
        while (true) {
          parse$$ACTION_BODY();
          if (!ok) {
            break;
          }
        }
        ok = true;
        _matchChar(125, '}');
        if (ok) {
          $3 = $4;
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      dynamic? $5;
      final $7 = _ch;
      final $8 = _pos;
      _matchChar(125, '}');
      final $6 = null;
      _ch = $7;
      _pos = $8;
      ok = !ok;
      if (ok) {
        _matchAny();
        if (ok) {
          $5 = $6;
        }
      }
      if (ok) {
        $0 = $5;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  String? parse$$COMMENT() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    final $4 = _matchChar(35, '#');
    if (ok) {
      while (true) {
        final $5 = _ch;
        final $6 = _pos;
        final $7 = _ch;
        final $8 = _pos;
        parse$$EOL();
        _ch = $7;
        _pos = $8;
        ok = !ok;
        if (ok) {
          _matchAny();
        }
        if (!ok) {
          _pos = $6;
          _ch = $5;
          break;
        }
      }
      ok = true;
      parse$$EOL();
      ok = true;
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  dynamic? parse$$EOL() {
    dynamic? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      String? $3;
      final $4 = _matchString('\r\n');
      if (ok) {
        $3 = $4;
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      int? $5;
      const $7 = [10, 10, 13, 13];
      final $6 = _matchRange($7);
      if (ok) {
        $5 = $6;
      }
      if (ok) {
        $0 = $5;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  dynamic? parse$$GLOBALS_BODY() {
    dynamic? $0;
    final $1 = _ch;
    final $2 = _pos;
    dynamic? $3;
    final $5 = _ch;
    final $6 = _pos;
    _matchString('}%');
    final $4 = null;
    _ch = $5;
    _pos = $6;
    ok = !ok;
    if (ok) {
      _matchAny();
      if (ok) {
        $3 = $4;
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  int? parse$$HEX_NUMBER() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    int? $3;
    _matchChar(92, 92);
    if (ok) {
      _matchChar(117, 'u');
      if (ok) {
        String? $4;
        final $5 = _pos;
        final $6 = _ch;
        final $7 = _pos;
        var $8 = 0;
        while (true) {
          const $9 = [48, 57, 65, 70, 97, 102];
          _matchRange($9);
          if (!ok) {
            break;
          }
          $8++;
        }
        ok = $8 != 0;
        if (!ok) {
          _pos = $7;
          _ch = $6;
        }
        if (ok) {
          $4 = _source.substring($5, _pos);
        }
        if (ok) {
          final d = $4!;
          late int $$;
          $$ = int.parse(d, radix: 16);
          $3 = $$;
        }
      }
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  String? parse$$IDENTIFIER() {
    String? $0;
    final $1 = _ch;
    final $2 = _pos;
    String? $3;
    String? $4;
    final $5 = _pos;
    final $6 = _ch;
    final $7 = _pos;
    parse$$IDENT_START();
    if (ok) {
      while (true) {
        parse$$IDENT_CONT();
        if (!ok) {
          break;
        }
      }
      ok = true;
    }
    if (!ok) {
      _pos = $7;
      _ch = $6;
    }
    if (ok) {
      $4 = _source.substring($5, _pos);
    }
    if (ok) {
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  int? parse$$IDENT_CONT() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      int? $3;
      final $4 = parse$$IDENT_START();
      if (ok) {
        $3 = $4;
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      int? $5;
      const $7 = [48, 57, 95, 95];
      final $6 = _matchRange($7);
      if (ok) {
        $5 = $6;
      }
      if (ok) {
        $0 = $5;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  int? parse$$IDENT_START() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    int? $3;
    const $5 = [65, 90, 97, 122];
    final $4 = _matchRange($5);
    if (ok) {
      $3 = $4;
    }
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  int? parse$$LITERAL_CHAR() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      int? $3;
      _matchChar(92, '\\');
      if (ok) {
        const $5 = [34, 34, 92, 92, 110, 110, 114, 114, 116, 116];
        final $4 = _matchRange($5);
        if (ok) {
          final c = $4!;
          late int $$;
          $$ = _escape(c);
          $3 = $$;
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      int? $6;
      final $7 = parse$$HEX_NUMBER();
      if (ok) {
        $6 = $7;
      }
      if (ok) {
        $0 = $6;
        break;
      }
      _pos = $2;
      _ch = $1;
      int? $8;
      final $9 = _ch;
      final $10 = _pos;
      _matchChar(92, '\\');
      _ch = $9;
      _pos = $10;
      ok = !ok;
      if (ok) {
        final $11 = _ch;
        final $12 = _pos;
        parse$$EOL();
        _ch = $11;
        _pos = $12;
        ok = !ok;
        if (ok) {
          final $13 = _matchAny();
          if (ok) {
            $8 = $13;
          }
        }
      }
      if (ok) {
        $0 = $8;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  List<int>? parse$$RANGE() {
    List<int>? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      List<int>? $3;
      final $4 = parse$$RANGE_CHAR();
      if (ok) {
        _matchChar(45, '-');
        if (ok) {
          final $5 = parse$$RANGE_CHAR();
          if (ok) {
            final s = $4!;
            final e = $5!;
            late List<int> $$;
            $$ = [s, e];
            $3 = $$;
          }
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      List<int>? $6;
      final $7 = parse$$RANGE_CHAR();
      if (ok) {
        final c = $7!;
        late List<int> $$;
        $$ = [c, c];
        $6 = $$;
      }
      if (ok) {
        $0 = $6;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  int? parse$$RANGE_CHAR() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      int? $3;
      _matchChar(92, '\\');
      if (ok) {
        const $5 = [92, 93, 110, 110, 114, 114, 116, 116];
        final $4 = _matchRange($5);
        if (ok) {
          final c = $4!;
          late int $$;
          $$ = _escape(c);
          $3 = $$;
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      int? $6;
      final $7 = parse$$HEX_NUMBER();
      if (ok) {
        $6 = $7;
      }
      if (ok) {
        $0 = $6;
        break;
      }
      _pos = $2;
      _ch = $1;
      int? $8;
      final $9 = _ch;
      final $10 = _pos;
      const $11 = [92, 93];
      _matchRange($11);
      _ch = $9;
      _pos = $10;
      ok = !ok;
      if (ok) {
        final $12 = _ch;
        final $13 = _pos;
        parse$$EOL();
        _ch = $12;
        _pos = $13;
        ok = !ok;
        if (ok) {
          final $14 = _matchAny();
          if (ok) {
            $8 = $14;
          }
        }
      }
      if (ok) {
        $0 = $8;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  dynamic? parse$$SPACE() {
    dynamic? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      int? $3;
      const $5 = [9, 9, 32, 32];
      final $4 = _matchRange($5);
      if (ok) {
        $3 = $4;
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      dynamic? $6;
      final $7 = parse$$EOL();
      if (ok) {
        $6 = $7;
      }
      if (ok) {
        $0 = $6;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  List? parse$$SPACING() {
    List? $0;
    final $1 = _ch;
    final $2 = _pos;
    List? $3;
    final $4 = [];
    while (true) {
      dynamic? $5;
      final $6 = _ch;
      final $7 = _pos;
      while (true) {
        dynamic? $8;
        final $9 = parse$$SPACE();
        if (ok) {
          $8 = $9;
        }
        if (ok) {
          $5 = $8;
          break;
        }
        _pos = $7;
        _ch = $6;
        String? $10;
        final $11 = parse$$COMMENT();
        if (ok) {
          $10 = $11;
        }
        if (ok) {
          $5 = $10;
          break;
        }
        _pos = $7;
        _ch = $6;
        break;
      }
      if (!ok) {
        break;
      }
      $4.add($5);
    }
    ok = true;
    $3 = $4;
    if (ok) {
      $0 = $3;
    } else {
      _pos = $2;
      _ch = $1;
    }
    return $0;
  }

  int? parse$$TERMINAL_CHAR() {
    int? $0;
    final $1 = _ch;
    final $2 = _pos;
    while (true) {
      int? $3;
      _matchString('//');
      if (ok) {
        final $4 = _matchChar(39, 39);
        if (ok) {
          $3 = $4;
        }
      }
      if (ok) {
        $0 = $3;
        break;
      }
      _pos = $2;
      _ch = $1;
      int? $5;
      const $7 = [32, 38, 40, 126];
      final $6 = _matchRange($7);
      if (ok) {
        $5 = $6;
      }
      if (ok) {
        $0 = $5;
        break;
      }
      _pos = $2;
      _ch = $1;
      break;
    }
    return $0;
  }

  void _buildError() {
    final names = <String>[];
    final ends = <int>[];
    var failEnd = 0;
    for (var i = 0; i < _failures.length; i += 2) {
      final name = _failures[i] as String;
      var end = _failures[i + 1] as int;
      if (end == -1) {
        end = _failStart;
      }

      if (failEnd < end) {
        failEnd = end;
      }

      names.add(name);
      ends.add(end);
    }

    final temp = <String>[];
    for (var i = 0; i < names.length; i++) {
      if (ends[i] == failEnd) {
        temp.add(names[i]);
      }
    }

    final expected = temp.toSet().toList();
    expected.sort();
    final sink = StringBuffer();
    if (_failStart == failEnd) {
      if (failEnd < _source.length) {
        sink.write('Unexpected character ');
        final ch = _getChar(_failStart);
        if (ch >= 32 && ch < 126) {
          sink.write('\'');
          sink.write(String.fromCharCode(ch));
          sink.write('\'');
        } else {
          sink.write('(');
          sink.write(ch);
          sink.write(')');
        }
      } else {
        sink.write('Unexpected end of input');
      }

      if (expected.isNotEmpty) {
        sink.write(', expected: ');
        sink.write(expected.join(', '));
      }
    } else {
      sink.write('Unterminated ');
      if (expected.isEmpty) {
        sink.write('unknown token');
      } else if (expected.length == 1) {
        sink.write('token ');
        sink.write(expected[0]);
      } else {
        sink.write('tokens ');
        sink.write(expected.join(', '));
      }
    }

    error = FormatException(sink.toString(), _source, _failStart);
  }

  void _fail(String name) {
    if (_pos < _failStart) {
      return;
    }

    if (_failStart < _pos) {
      _failStart = _pos;
      _failures = [];
    }

    _failures.add(name);
    _failures.add(_failPos);
  }

  int _getChar(int pos) {
    if (pos < _source.length) {
      var ch = _source.codeUnitAt(pos);
      if (ch >= 0xD800 && ch <= 0xDBFF) {
        if (pos + 1 < _source.length) {
          final ch2 = _source.codeUnitAt(pos + 1);
          if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {
            ch = ((ch - 0xD800) << 10) + (ch2 - 0xDC00) + 0x10000;
          } else {
            throw FormatException('Unpaired high surrogate', _source, pos);
          }
        } else {
          throw FormatException('The source has been exhausted', _source, pos);
        }
      } else {
        if (ch >= 0xDC00 && ch <= 0xDFFF) {
          throw FormatException(
              'UTF-16 surrogate values are illegal in UTF-32', _source, pos);
        }
      }

      return ch;
    }

    return _eof;
  }

  int? _matchAny() {
    if (_ch == _eof) {
      if (_failPos < _pos) {
        _failPos = _pos;
      }

      ok = false;
      return null;
    }

    final ch = _ch;
    _pos += _ch <= 0xffff ? 1 : 2;
    _ch = _getChar(_pos);
    ok = true;
    return ch;
  }

  T? _matchChar<T>(int ch, T? result) {
    if (ch != _ch) {
      if (_failPos < _pos) {
        _failPos = _pos;
      }

      ok = false;
      return null;
    }

    _pos += _ch <= 0xffff ? 1 : 2;
    _ch = _getChar(_pos);
    ok = true;
    return result;
  }

  int? _matchRange(List<int> ranges) {
    // Use binary search
    for (var i = 0; i < ranges.length; i += 2) {
      if (ranges[i] <= _ch) {
        if (ranges[i + 1] >= _ch) {
          final ch = _ch;
          _pos += _ch <= 0xffff ? 1 : 2;
          _ch = _getChar(_pos);
          ok = true;
          return ch;
        }
      } else {
        break;
      }
    }

    ok = false;
    if (_failPos < _pos) {
      _failPos = _pos;
    }

    return null;
  }

  String? _matchString(String text) {
    var i = 0;
    if (_ch == text.codeUnitAt(0)) {
      i++;
      if (_pos + text.length <= _source.length) {
        for (; i < text.length; i++) {
          if (text.codeUnitAt(i) != _source.codeUnitAt(_pos + i)) {
            break;
          }
        }
      }
    }

    ok = i == text.length;
    if (ok) {
      _pos = _pos + text.length;
      _ch = _getChar(_pos);
      return text;
    } else {
      final pos = _pos + i;
      if (_failPos < pos) {
        _failPos = pos;
      }
      return null;
    }
  }

  void _reset() {
    error = null;
    _failPos = 0;
    _failStart = 0;
    _failures = [];
    _pos = 0;
    _ch = _getChar(0);
    ok = false;
  }
}
// ignore: unused_element
