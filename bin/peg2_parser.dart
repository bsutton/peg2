// Generated by 'peg2'
// https://pub.dev/packages/peg2

import 'package:peg2/grammar.dart';
import 'package:peg2/expressions.dart';

int _escape(int c) {
  switch (c) {
    case 110:
      return 0xA;
    case 114:
      return 0xD;
    case 116:
      return 0x9;
  }

  return c;
}

Expression _prefix(String prefix, Expression expression, String variable) {
  switch (prefix) {
    case '&':
      expression = AndPredicateExpression(expression);
      break;
    case '!':
      expression = NotPredicateExpression(expression);
      break;
  }

  expression.variable = variable;
  return expression;
}

Expression _suffix(String suffix, Expression expression) {
  switch (suffix) {
    case '?':
      return OptionalExpression(expression);
    case '*':
      return ZeroOrMoreExpression(expression);
    case '+':
      return OneOrMoreExpression(expression);
  }

  return expression;
}

class Peg2Parser {
  static const _eof = 0x110000;

  FormatException error;

  int _c;

  int _error;

  List<String> _expected;

  int _failure;

  List<int> _input;

  List<bool> _memoizable;

  List<List<_Memo>> _memos;

  var _mresult;

  int _pos;

  bool _predicate;

  dynamic _result;

  bool _success;

  String _text;

  List<int> _trackCid;

  List<int> _trackPos;

  dynamic parse(String text) {
    if (text == null) {
      throw ArgumentError.notNull('text');
    }
    _text = text;
    _input = _toRunes(text);
    _reset();
    final result = _parseGrammar(0, true);
    _buildError();
    _expected = null;
    _input = null;
    return result;
  }

  void _buildError() {
    if (_success) {
      error = null;
      return;
    }

    String escape(int c) {
      switch (c) {
        case 10:
          return r'\n';
        case 13:
          return r'\r';
        case 09:
          return r'\t';
        case _eof:
          return 'end of file';
      }
      return String.fromCharCode(c);
    }

    String getc(int position) {
      if (position < _text.length) {
        return "'${escape(_input[position])}'";
      }
      return 'end of file';
    }

    String report(String message, String source, int start) {
      if (start < 0 || start > source.length) {
        start = null;
      }

      final sb = StringBuffer();
      sb.write(message);
      var line = 0;
      var col = 0;
      var lineStart = 0;
      var started = false;
      if (start != null) {
        for (var i = 0; i < source.length; i++) {
          final c = source.codeUnitAt(i);
          if (!started) {
            started = true;
            lineStart = i;
            line++;
            col = 1;
          } else {
            col++;
          }
          if (c == 10) {
            started = false;
          }
          if (start == i) {
            break;
          }
        }
      }

      if (start == null) {
        sb.writeln('.');
      } else if (line == 0 || start == source.length) {
        sb.write(' (at offset ');
        sb.write(start);
        sb.writeln('):');
      } else {
        sb.write(' (at line ');
        sb.write(line);
        sb.write(', column ');
        sb.write(col);
        sb.writeln('):');
      }

      List<int> escape(int c) {
        switch (c) {
          case 9:
            return [92, 116];
          case 10:
            return [92, 110];
          case 13:
            return [92, 114];
          default:
            return [c];
        }
      }

      const max = 70;
      if (start != null) {
        final c1 = <int>[];
        final c2 = <int>[];
        final half = max ~/ 2;
        var cr = false;
        for (var i = start; i >= lineStart && c1.length < half; i--) {
          if (i == source.length) {
            c2.insert(0, 94);
          } else {
            final c = source.codeUnitAt(i);
            final escaped = escape(c);
            c1.insertAll(0, escaped);
            if (c == 10) {
              cr = true;
            }

            final r = i == start ? 94 : 32;
            for (var k = 0; k < escaped.length; k++) {
              c2.insert(0, r);
            }
          }
        }

        for (var i = start + 1;
            i < source.length && c1.length < max && !cr;
            i++) {
          final c = source.codeUnitAt(i);
          final escaped = escape(c);
          c1.addAll(escaped);
          if (c == 10) {
            break;
          }
        }

        final text1 = String.fromCharCodes(c1);
        final text2 = String.fromCharCodes(c2);
        sb.writeln(text1);
        sb.writeln(text2);
      }

      return sb.toString();
    }

    final temp = _expected.toList();
    temp.sort((e1, e2) => e1.compareTo(e2));
    final expected = temp.toSet();
    final hasMalformed = false;
    if (expected.isNotEmpty) {
      if (!hasMalformed) {
        final sb = StringBuffer();
        sb.write('Expected ');
        sb.write(expected.join(', '));
        sb.write(' but found ');
        sb.write(getc(_error));
        final title = sb.toString();
        final message = report(title, _text, _error);
        error = FormatException(message);
      } else {
        final reason = _error == _text.length ? 'Unterminated' : 'Malformed';
        final sb = StringBuffer();
        sb.write(reason);
        sb.write(' ');
        sb.write(expected.join(', '));
        final title = sb.toString();
        final message = report(title, _text, _error);
        error = FormatException(message);
      }
    } else {
      final sb = StringBuffer();
      sb.write('Unexpected character ');
      sb.write(getc(_error));
      final title = sb.toString();
      final message = report(title, _text, _error);
      error = FormatException(message);
    }
  }

  void _fail(List<String> expected) {
    if (_error < _failure) {
      _error = _failure;
      _expected = [];
    }
    if (_error == _failure) {
      _expected.addAll(expected);
    }
  }

  int _matchRanges(List<int> ranges) {
    int result;
    _success = false;
    for (var i = 0; i < ranges.length; i += 2) {
      if (ranges[i] <= _c) {
        if (ranges[i + 1] >= _c) {
          result = _c;
          _c = _input[_pos += _c <= 0xffff ? 1 : 2];
          _success = true;
          break;
        }
      } else {
        break;
      }
    }

    if (!_success) {
      _failure = _pos;
    }

    return result;
  }

  String _matchString(String text) {
    String result;
    final length = text.length;
    final rest = _text.length - _pos;
    final count = length > rest ? rest : length;
    var pos = _pos;
    var i = 0;
    for (; i < count; i++, pos++) {
      if (text.codeUnitAt(i) != _text.codeUnitAt(pos)) {
        break;
      }
    }

    if (_success = i == length) {
      _c = _input[_pos += length];
      result = text;
    } else {
      _failure = _pos + i;
    }

    return result;
  }

  bool _memoized(int id, int cid) {
    final memos = _memos[_pos];
    if (memos != null) {
      for (var i = 0; i < memos.length; i++) {
        final memo = memos[i];
        if (memo.id == id) {
          _pos = memo.pos;
          _mresult = memo.result;
          _success = memo.success;
          _c = _input[_pos];
          return true;
        }
      }
    }

    if (_memoizable[cid] != null) {
      return false;
    }

    final lastCid = _trackCid[id];
    final lastPos = _trackPos[id];
    _trackCid[id] = cid;
    _trackPos[id] = _pos;
    if (lastCid == null) {
      return false;
    }

    if (lastPos == _pos) {
      if (lastCid != cid) {
        _memoizable[lastCid] = true;
        _memoizable[cid] = false;
      }
    }

    return false;
  }

  void _memoize(int id, int pos, result) {
    var memos = _memos[pos];
    if (memos == null) {
      memos = [];
      _memos[pos] = memos;
    }

    final memo = _Memo(
      id: id,
      pos: _pos,
      result: result,
      success: _success,
    );

    memos.add(memo);
  }

  void _reset() {
    _c = _input[0];
    _error = 0;
    _expected = [];
    _failure = -1;
    _memoizable = [];
    _memoizable.length = 444;
    _memos = [];
    _memos.length = _input.length + 1;
    _pos = 0;
    _predicate = false;
    _success = false;
    _trackCid = [];
    _trackCid.length = 444;
    _trackPos = [];
    _trackPos.length = 444;
  }

  List<int> _toRunes(String source) {
    final length = source.length;
    final result = List<int>(length + 1);
    for (var pos = 0; pos < length;) {
      int c;
      final start = pos;
      final leading = source.codeUnitAt(pos++);
      if ((leading & 0xFC00) == 0xD800 && pos < length) {
        final trailing = source.codeUnitAt(pos);
        if ((trailing & 0xFC00) == 0xDC00) {
          c = 0x10000 + ((leading & 0x3FF) << 10) + (trailing & 0x3FF);
          pos++;
        } else {
          c = leading;
        }
      } else {
        c = leading;
      }

      result[start] = c;
    }

    result[length] = 0x110000;
    return result;
  }

  Grammar _parseGrammar(int $00, bool $01) {
    Grammar $02;
    final $03 = _pos;
    final $04 = _c;
    Grammar $06;
    _parse_leading_spaces(3, false);
    final $011 = _parse_globals(5, $01);
    final $012 = $011;
    final $013 = _parse_members(7, $01);
    final $014 = $013;
    List<ProductionRule> $015;
    if ($01) {
      $015 = [];
    }
    var $016 = false;
    for (;;) {
      final $017 = _parseDefinition(9, $01);
      if (!_success) {
        _success = $016;
        if (!_success) {
          $015 = null;
        }
        break;
      }
      if ($01) {
        $015.add($017);
      }
      $016 = true;
    }
    if (_success) {
      _parse_end_of_file(10, false);
      if (_success) {
        final g = $012;
        final m = $014;
        final d = $015;
        Grammar $$;
        $$ = Grammar(d, g, m);
        $06 = $$;
      }
    }
    if (!_success) {
      _c = $04;
      _pos = $03;
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const [
        '\'non terminal name\'',
        '\'terminal name\'',
        '\'sub terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $02;
  }

  ProductionRule _parseDefinition(int $00, bool $01) {
    ProductionRule $02;
    final $03 = _pos;
    for (;;) {
      ProductionRule $06;
      final $09 = _parseNonterminalDefinition(13, $01);
      if (_success) {
        $06 = $09;
        $02 = $06;
        break;
      }
      ProductionRule $010;
      final $013 = _parseTerminalDefinition(15, $01);
      if (_success) {
        $010 = $013;
        $02 = $010;
        break;
      }
      ProductionRule $014;
      final $017 = _parseSubterminalDefinition(17, $01);
      if (_success) {
        $014 = $017;
        $02 = $014;
        break;
      }
      break;
    }
    if (!_success && _error == $03) {
      _fail(const [
        '\'non terminal name\'',
        '\'terminal name\'',
        '\'sub terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $02;
  }

  ProductionRule _parseNonterminalDefinition(int $00, bool $01) {
    ProductionRule $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      ProductionRule $06;
      final $07 = _c;
      final $08 = _pos;
      final $09 = _parseType(20, $01);
      if (_success) {
        final $010 = _parse_non_terminal_name(21, $01);
        if (_success) {
          _parse_$EqualSign(22, false);
          if (_success) {
            final $012 = _parseNonterminalExpression(23, $01);
            if (_success) {
              _parse_$Semicolon(24, false);
              if (_success) {
                final t = $09;
                final n = $010;
                final e = $012;
                ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, t);
                $06 = $$;
              }
            }
          }
        }
        if (!_success) {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      ProductionRule $014;
      final $015 = _c;
      final $016 = _pos;
      final $017 = _parse_non_terminal_name(26, $01);
      if (_success) {
        _parse_$EqualSign(27, false);
        if (_success) {
          final $019 = _parseNonterminalExpression(28, $01);
          if (_success) {
            _parse_$Semicolon(29, false);
            if (_success) {
              final n = $017;
              final e = $019;
              ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.nonterminal, e, null);
              $014 = $$;
            }
          }
        }
        if (!_success) {
          _c = $015;
          _pos = $016;
        }
      }
      if (_success) {
        $02 = $014;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    if (!_success && _error == $03) {
      _fail(const [
        '\'non terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $02;
  }

  OrderedChoiceExpression _parseNonterminalExpression(int $00, bool $01) {
    OrderedChoiceExpression $02;
    final $03 = _pos;
    final $04 = _c;
    OrderedChoiceExpression $06;
    final $09 = _parseNonterminalSequence(32, $01);
    if (_success) {
      List<SequenceExpression> $010;
      if ($01) {
        $010 = [];
      }
      for (;;) {
        SequenceExpression $011;
        final $012 = _pos;
        final $014 = _c;
        SequenceExpression $016;
        _parse_$Slash(36, false);
        if (_success) {
          final $020 = _parseNonterminalSequence(37, $01);
          if (_success) {
            $016 = $020;
          } else {
            _c = $014;
            _pos = $012;
          }
        }
        $011 = $016;
        if (!_success && _error == $012) {
          _fail(const ['\'/\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($01) {
          $010.add($011);
        }
      }
      if (_success) {
        final e = $09;
        final n = $010;
        OrderedChoiceExpression $$;
        $$ = OrderedChoiceExpression([e, ...n]);
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $02;
  }

  SequenceExpression _parseNonterminalSequence(int $00, bool $01) {
    SequenceExpression $02;
    final $03 = _pos;
    final $04 = _c;
    SequenceExpression $06;
    List<Expression> $09;
    if ($01) {
      $09 = [];
    }
    var $010 = false;
    for (;;) {
      final $011 = _parseNonterminalPrefix(41, $01);
      if (!_success) {
        _success = $010;
        if (!_success) {
          $09 = null;
        }
        break;
      }
      if ($01) {
        $09.add($011);
      }
      $010 = true;
    }
    if (_success) {
      final $012 = _parse_action(43, $01);
      final $013 = $012;
      _success = true;
      {
        final e = $09;
        final a = $013;
        SequenceExpression $$;
        $$ = SequenceExpression(e, a);
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $02;
  }

  Expression _parseNonterminalPrefix(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    Expression $06;
    final $09 = _parse_semantic_value(47, $01);
    final $010 = $09;
    String $011;
    for (;;) {
      String $016;
      final $019 = _parse_$Ampersand(51, $01);
      if (_success) {
        $016 = $019;
        $011 = $016;
        break;
      }
      String $020;
      final $023 = _parse_$ExclamationMark(53, $01);
      if (_success) {
        $020 = $023;
        $011 = $020;
        break;
      }
      break;
    }
    if (!_success && _error == $03) {
      _fail(const ['\'&\'', '\'!\'']);
    }
    final $024 = $011;
    final $025 = _parseNonterminalSuffix(54, $01);
    if (_success) {
      final s = $010;
      final p = $024;
      final e = $025;
      Expression $$;
      $$ = _prefix(p, e, s);
      $06 = $$;
    }
    if (!_success) {
      _c = $04;
      _pos = $03;
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $02;
  }

  Expression _parseNonterminalSuffix(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    Expression $06;
    final $09 = _parseNonterminalPrimary(57, $01);
    if (_success) {
      String $010;
      final $011 = _pos;
      for (;;) {
        String $015;
        final $018 = _parse_$QuestionMark(61, $01);
        if (_success) {
          $015 = $018;
          $010 = $015;
          break;
        }
        String $019;
        final $022 = _parse_$Asterisk(63, $01);
        if (_success) {
          $019 = $022;
          $010 = $019;
          break;
        }
        String $023;
        final $026 = _parse_$PlusSign(65, $01);
        if (_success) {
          $023 = $026;
          $010 = $023;
          break;
        }
        break;
      }
      if (!_success && _error == $011) {
        _fail(const ['\'?\'', '\'*\'', '\'+\'']);
      }
      final $027 = $010;
      _success = true;
      {
        final e = $09;
        final s = $027;
        Expression $$;
        $$ = _suffix(s, e);
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $02;
  }

  Expression _parseNonterminalPrimary(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      Expression $06;
      final $09 = _parse_non_terminal_name(68, $01);
      if (_success) {
        final n = $09;
        Expression $$;
        $$ = NonterminalExpression(n);
        $06 = $$;
      }
      if (_success) {
        $02 = $06;
        break;
      }
      Expression $010;
      final $013 = _parse_terminal_name(70, $01);
      if (_success) {
        final n = $013;
        Expression $$;
        $$ = TerminalExpression(n);
        $010 = $$;
      }
      if (_success) {
        $02 = $010;
        break;
      }
      Expression $014;
      final $015 = _c;
      final $016 = _pos;
      _parse_$LeftParenthesis(72, false);
      if (_success) {
        final $018 = _parseNonterminalExpression(73, $01);
        if (_success) {
          _parse_$RightParenthesis(74, false);
          if (_success) {
            $014 = $018;
          }
        }
        if (!_success) {
          _c = $015;
          _pos = $016;
        }
      }
      if (_success) {
        $02 = $014;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    if (!_success && _error == $03) {
      _fail(const ['\'non terminal name\'', '\'terminal name\'', '\'(\'']);
    }
    return $02;
  }

  ProductionRule _parseTerminalDefinition(int $00, bool $01) {
    ProductionRule $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      ProductionRule $06;
      final $07 = _c;
      final $08 = _pos;
      final $09 = _parseType(77, $01);
      if (_success) {
        final $010 = _parse_terminal_name(78, $01);
        if (_success) {
          _parse_$EqualSign(79, false);
          if (_success) {
            final $012 = _parseExpression(80, $01);
            if (_success) {
              _parse_$Semicolon(81, false);
              if (_success) {
                final t = $09;
                final n = $010;
                final e = $012;
                ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.terminal, e, t);
                $06 = $$;
              }
            }
          }
        }
        if (!_success) {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      ProductionRule $014;
      final $015 = _c;
      final $016 = _pos;
      final $017 = _parse_terminal_name(83, $01);
      if (_success) {
        _parse_$EqualSign(84, false);
        if (_success) {
          final $019 = _parseExpression(85, $01);
          if (_success) {
            _parse_$Semicolon(86, false);
            if (_success) {
              final n = $017;
              final e = $019;
              ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.terminal, e, null);
              $014 = $$;
            }
          }
        }
        if (!_success) {
          _c = $015;
          _pos = $016;
        }
      }
      if (_success) {
        $02 = $014;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    if (!_success && _error == $03) {
      _fail(const ['\'terminal name\'', '\'library prefix\'', '\'type name\'']);
    }
    return $02;
  }

  OrderedChoiceExpression _parseExpression(int $00, bool $01) {
    OrderedChoiceExpression $02;
    final $03 = _pos;
    final $04 = _c;
    OrderedChoiceExpression $06;
    final $09 = _parseSequence(89, $01);
    if (_success) {
      List<SequenceExpression> $010;
      if ($01) {
        $010 = [];
      }
      for (;;) {
        SequenceExpression $011;
        final $012 = _pos;
        final $014 = _c;
        SequenceExpression $016;
        _parse_$Slash(93, false);
        if (_success) {
          final $020 = _parseSequence(94, $01);
          if (_success) {
            $016 = $020;
          } else {
            _c = $014;
            _pos = $012;
          }
        }
        $011 = $016;
        if (!_success && _error == $012) {
          _fail(const ['\'/\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($01) {
          $010.add($011);
        }
      }
      if (_success) {
        final e = $09;
        final n = $010;
        OrderedChoiceExpression $$;
        $$ = OrderedChoiceExpression([e, ...n]);
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $02;
  }

  SequenceExpression _parseSequence(int $00, bool $01) {
    SequenceExpression $02;
    final $03 = _pos;
    final $04 = _c;
    SequenceExpression $06;
    List<Expression> $09;
    if ($01) {
      $09 = [];
    }
    var $010 = false;
    for (;;) {
      final $011 = _parsePrefix(98, $01);
      if (!_success) {
        _success = $010;
        if (!_success) {
          $09 = null;
        }
        break;
      }
      if ($01) {
        $09.add($011);
      }
      $010 = true;
    }
    if (_success) {
      final $012 = _parse_action(100, $01);
      final $013 = $012;
      _success = true;
      {
        final e = $09;
        final a = $013;
        SequenceExpression $$;
        $$ = SequenceExpression(e, a);
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $02;
  }

  Expression _parsePrefix(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    Expression $06;
    final $09 = _parse_semantic_value(104, $01);
    final $010 = $09;
    String $011;
    for (;;) {
      String $016;
      final $019 = _parse_$Ampersand(108, $01);
      if (_success) {
        $016 = $019;
        $011 = $016;
        break;
      }
      String $020;
      final $023 = _parse_$ExclamationMark(110, $01);
      if (_success) {
        $020 = $023;
        $011 = $020;
        break;
      }
      break;
    }
    if (!_success && _error == $03) {
      _fail(const ['\'&\'', '\'!\'']);
    }
    final $024 = $011;
    final $025 = _parseSuffix(111, $01);
    if (_success) {
      final s = $010;
      final p = $024;
      final e = $025;
      Expression $$;
      $$ = _prefix(p, e, s);
      $06 = $$;
    }
    if (!_success) {
      _c = $04;
      _pos = $03;
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $02;
  }

  Expression _parseSuffix(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    Expression $06;
    final $09 = _parsePrimary(114, $01);
    if (_success) {
      String $010;
      final $011 = _pos;
      for (;;) {
        String $015;
        final $018 = _parse_$QuestionMark(118, $01);
        if (_success) {
          $015 = $018;
          $010 = $015;
          break;
        }
        String $019;
        final $022 = _parse_$Asterisk(120, $01);
        if (_success) {
          $019 = $022;
          $010 = $019;
          break;
        }
        String $023;
        final $026 = _parse_$PlusSign(122, $01);
        if (_success) {
          $023 = $026;
          $010 = $023;
          break;
        }
        break;
      }
      if (!_success && _error == $011) {
        _fail(const ['\'?\'', '\'*\'', '\'+\'']);
      }
      final $027 = $010;
      _success = true;
      {
        final e = $09;
        final s = $027;
        Expression $$;
        $$ = _suffix(s, e);
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $02;
  }

  Expression _parsePrimary(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      Expression $06;
      final $09 = _parse_sub_terminal_name(125, $01);
      if (_success) {
        final n = $09;
        Expression $$;
        $$ = SubterminalExpression(n);
        $06 = $$;
      }
      if (_success) {
        $02 = $06;
        break;
      }
      Expression $010;
      final $011 = _c;
      final $012 = _pos;
      _parse_$LeftParenthesis(127, false);
      if (_success) {
        final $014 = _parseExpression(128, $01);
        if (_success) {
          _parse_$RightParenthesis(129, false);
          if (_success) {
            $010 = $014;
          }
        }
        if (!_success) {
          _c = $011;
          _pos = $012;
        }
      }
      if (_success) {
        $02 = $010;
        break;
      }
      _c = $04;
      _pos = $03;
      Expression $016;
      final $019 = _parse_literal(131, $01);
      if (_success) {
        $016 = $019;
        $02 = $016;
        break;
      }
      Expression $020;
      final $023 = _parse_character_class(133, $01);
      if (_success) {
        $020 = $023;
        $02 = $020;
        break;
      }
      Expression $024;
      _parse_$Period(135, $01);
      if (_success) {
        Expression $$;
        $$ = AnyCharacterExpression();
        $024 = $$;
      }
      if (_success) {
        $02 = $024;
        break;
      }
      Expression $028;
      final $029 = _c;
      final $030 = _pos;
      _parse_$LessThanSign(137, false);
      if (_success) {
        final $032 = _parseExpression(138, $01);
        if (_success) {
          _parse_$GreaterThanSign(139, false);
          if (_success) {
            final e = $032;
            Expression $$;
            $$ = CaptureExpression(e);
            $028 = $$;
          }
        }
        if (!_success) {
          _c = $029;
          _pos = $030;
        }
      }
      if (_success) {
        $02 = $028;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    if (!_success && _error == $03) {
      _fail(const [
        '\'sub terminal name\'',
        '\'(\'',
        '\'literal\'',
        '\'character class\'',
        '\'.\'',
        '\'<\''
      ]);
    }
    return $02;
  }

  ProductionRule _parseSubterminalDefinition(int $00, bool $01) {
    ProductionRule $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      ProductionRule $06;
      final $07 = _c;
      final $08 = _pos;
      final $09 = _parseType(142, $01);
      if (_success) {
        final $010 = _parse_sub_terminal_name(143, $01);
        if (_success) {
          _parse_$EqualSign(144, false);
          if (_success) {
            final $012 = _parseExpression(145, $01);
            if (_success) {
              _parse_$Semicolon(146, false);
              if (_success) {
                final t = $09;
                final n = $010;
                final e = $012;
                ProductionRule $$;
                $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, t);
                $06 = $$;
              }
            }
          }
        }
        if (!_success) {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      ProductionRule $014;
      final $015 = _c;
      final $016 = _pos;
      final $017 = _parse_sub_terminal_name(148, $01);
      if (_success) {
        _parse_$EqualSign(149, false);
        if (_success) {
          final $019 = _parseExpression(150, $01);
          if (_success) {
            _parse_$Semicolon(151, false);
            if (_success) {
              final n = $017;
              final e = $019;
              ProductionRule $$;
              $$ = ProductionRule(n, ProductionRuleKind.subterminal, e, null);
              $014 = $$;
            }
          }
        }
        if (!_success) {
          _c = $015;
          _pos = $016;
        }
      }
      if (_success) {
        $02 = $014;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    if (!_success && _error == $03) {
      _fail(const [
        '\'sub terminal name\'',
        '\'library prefix\'',
        '\'type name\''
      ]);
    }
    return $02;
  }

  String _parseType(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $06;
    final $09 = _parseTypeName(154, $01);
    if (_success) {
      List<String> $010;
      final $011 = _pos;
      final $013 = _c;
      List<String> $015;
      _parse_$LessThanSign(158, false);
      if (_success) {
        final $019 = _parseTypeArguments(159, $01);
        if (_success) {
          _parse_$GreaterThanSign(160, false);
          if (_success) {
            $015 = $019;
          }
        }
        if (!_success) {
          _c = $013;
          _pos = $011;
        }
      }
      $010 = $015;
      if (!_success && _error == $011) {
        _fail(const ['\'<\'']);
      }
      final $021 = $010;
      _success = true;
      {
        final n = $09;
        final a = $021;
        String $$;
        $$ = n + (a == null ? '' : '<' + a.join(', ') + '>');
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const ['\'library prefix\'', '\'type name\'']);
    }
    return $02;
  }

  String _parseTypeName(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      String $06;
      final $07 = _c;
      final $08 = _pos;
      final $09 = _parse_library_prefix(163, $01);
      if (_success) {
        _parse_$Period(164, false);
        if (_success) {
          final $011 = _parse_type_name(165, $01);
          if (_success) {
            final p = $09;
            final n = $011;
            String $$;
            $$ = '$p.$n';
            $06 = $$;
          }
        }
        if (!_success) {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      String $012;
      final $015 = _parse_type_name(167, $01);
      if (_success) {
        $012 = $015;
        $02 = $012;
        break;
      }
      break;
    }
    if (!_success && _error == $03) {
      _fail(const ['\'library prefix\'', '\'type name\'']);
    }
    return $02;
  }

  List<String> _parseTypeArguments(int $00, bool $01) {
    List<String> $02;
    final $03 = _pos;
    final $04 = _c;
    List<String> $06;
    final $09 = _parseType(170, $01);
    if (_success) {
      List<String> $010;
      if ($01) {
        $010 = [];
      }
      for (;;) {
        String $011;
        final $012 = _pos;
        final $014 = _c;
        String $016;
        _parse_$Comma(174, false);
        if (_success) {
          final $020 = _parseType(175, $01);
          if (_success) {
            $016 = $020;
          } else {
            _c = $014;
            _pos = $012;
          }
        }
        $011 = $016;
        if (!_success && _error == $012) {
          _fail(const ['\',\'']);
        }
        if (!_success) {
          _success = true;
          break;
        }
        if ($01) {
          $010.add($011);
        }
      }
      if (_success) {
        final t = $09;
        final n = $010;
        List<String> $$;
        $$ = [t, ...n];
        $06 = $$;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    if (!_success && _error == $03) {
      _fail(const ['\'library prefix\'', '\'type name\'']);
    }
    return $02;
  }

  String _parse_non_terminal_name(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    final $010 = _parse$$IDENTIFIER(178, $01);
    if (_success) {
      _parse$$SPACING(179, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'non terminal name\'']);
    }
    return $02;
  }

  String _parse_terminal_name(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    final $012 = $01;
    $01 = false;
    final $014 = _pos;
    final $016 = _c;
    if (_c == 39) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      var $024 = false;
      for (;;) {
        final $026 = _pos;
        final $028 = _c;
        final $036 = $01;
        $01 = false;
        if (_c == 39) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        _success = !_success;
        _c = $028;
        _pos = $026;
        $01 = $036;
        if (_success) {
          _parse$$TERMINAL_CHAR(191, false);
          if (!_success) {
            _c = $028;
            _pos = $026;
          }
        }
        if (!_success) {
          _success = $024;
          break;
        }
        $024 = true;
      }
      if (_success) {
        if (_c == 39) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
      }
      if (!_success) {
        _c = $016;
        _pos = $014;
      }
    }
    if (_success) {
      $010 = _text.substring($03, _pos);
    }
    $01 = $012;
    if (_success) {
      _parse$$SPACING(193, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'terminal name\'']);
    }
    return $02;
  }

  String _parse_sub_terminal_name(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    final $012 = $01;
    $01 = false;
    final $014 = _pos;
    final $016 = _c;
    if (_c == 64) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$IDENTIFIER(200, false);
      if (!_success) {
        _c = $016;
        _pos = $014;
      }
    }
    if (_success) {
      $010 = _text.substring($03, _pos);
    }
    $01 = $012;
    if (_success) {
      _parse$$SPACING(201, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'sub terminal name\'']);
    }
    return $02;
  }

  String _parse_semantic_value(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    final $010 = _parse$$IDENTIFIER(204, $01);
    if (_success) {
      if (_c == 58) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $07 = $010;
      } else {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'semantic value\'']);
    }
    return $02;
  }

  String _parse_type_name(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    final $012 = $01;
    $01 = false;
    final $014 = _pos;
    final $016 = _c;
    _parse$$IDENTIFIER(211, false);
    if (_success) {
      if (_c == 63) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      _success = true;
      if (!_success) {
        _c = $016;
        _pos = $014;
      }
    }
    if (_success) {
      $010 = _text.substring($03, _pos);
    }
    $01 = $012;
    if (_success) {
      _parse$$SPACING(214, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'type name\'']);
    }
    return $02;
  }

  String _parse_library_prefix(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    String $07;
    String $010;
    final $012 = $01;
    $01 = false;
    final $014 = _pos;
    final $016 = _c;
    if (_c == 95) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    _parse$$IDENTIFIER(222, false);
    if (!_success) {
      _c = $016;
      _pos = $014;
    }
    if (_success) {
      $010 = _text.substring($03, _pos);
    }
    $01 = $012;
    if (_success) {
      $07 = $010;
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'library prefix\'']);
    }
    return $02;
  }

  String _parse_$Semicolon(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 59) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(226, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\';\'']);
    }
    return $02;
  }

  String _parse_action(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    if (_c == 123) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      String $011;
      final $012 = _pos;
      final $013 = $01;
      $01 = false;
      for (;;) {
        _parse$$ACTION_BODY(234, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
      if (_success) {
        $011 = _text.substring($012, _pos);
      }
      $01 = $013;
      if (_c == 125) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        _parse$$SPACING(236, false);
        $07 = $011;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'action\'']);
    }
    return $02;
  }

  String _parse_$Ampersand(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 38) {
      _success = true;
      $010 = '&';
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(240, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'&\'']);
    }
    return $02;
  }

  Expression _parse_character_class(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    Expression $07;
    if (_c == 91) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      List<List<int>> $011;
      if ($01) {
        $011 = [];
      }
      var $012 = false;
      for (;;) {
        List<int> $013;
        final $014 = _pos;
        final $016 = _c;
        List<int> $019;
        final $024 = $01;
        $01 = false;
        if (_c == 93) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        _success = !_success;
        _c = $016;
        _pos = $014;
        $01 = $024;
        if (_success) {
          final $027 = _parse$$RANGE(249, $01);
          if (_success) {
            $019 = $027;
          } else {
            _c = $016;
            _pos = $014;
          }
        }
        $013 = $019;
        if (!_success) {
          _success = $012;
          if (!_success) {
            $011 = null;
          }
          break;
        }
        if ($01) {
          $011.add($013);
        }
        $012 = true;
      }
      if (_success) {
        if (_c == 93) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          _parse$$SPACING(251, false);
          if (_success) {
            final r = $011;
            Expression $$;
            $$ = CharacterClassExpression(r);
            $07 = $$;
          }
        }
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'character class\'']);
    }
    return $02;
  }

  String _parse_$RightParenthesis(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 41) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(255, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\')\'']);
    }
    return $02;
  }

  String _parse_$Period(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 46) {
      _success = true;
      $010 = '.';
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(259, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'.\'']);
    }
    return $02;
  }

  dynamic _parse_end_of_file(int $00, bool $01) {
    dynamic $02;
    final $03 = _pos;
    final $04 = _c;
    dynamic $07;
    final $012 = $01;
    $01 = false;
    if (_c >= 0 && _c <= 1114111) {
      _success = true;
      _c = _input[_pos += _c <= 65535 ? 1 : 2];
    } else {
      _success = false;
      _failure = _pos;
    }
    _success = !_success;
    _c = $04;
    _pos = $03;
    $01 = $012;
    var $014;
    if (_success) {
      $07 = $014;
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'end of file\'']);
    }
    return $02;
  }

  String _parse_globals(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    if (_c == 37) {
      _matchString('%{');
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      String $011;
      final $012 = _pos;
      final $013 = $01;
      $01 = false;
      for (;;) {
        _parse$$GLOBALS_BODY(271, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
      if (_success) {
        $011 = _text.substring($012, _pos);
      }
      $01 = $013;
      if (_c == 125) {
        _matchString('}%');
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        _parse$$SPACING(273, false);
        $07 = $011;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'globals\'']);
    }
    return $02;
  }

  List _parse_leading_spaces(int $00, bool $01) {
    List $02;
    $02 = _parse$$SPACING(276, false);
    if (!_success && _error <= _failure) {
      _fail(const ['\'leading spaces\'']);
    }
    return $02;
  }

  String _parse_$EqualSign(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 61) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(280, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'=\'']);
    }
    return $02;
  }

  Expression _parse_literal(int $00, bool $01) {
    Expression $02;
    final $03 = _pos;
    final $04 = _c;
    Expression $07;
    if (_c == 34) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      List<int> $011;
      if ($01) {
        $011 = [];
      }
      for (;;) {
        int $012;
        final $013 = _pos;
        final $015 = _c;
        int $018;
        final $023 = $01;
        $01 = false;
        if (_c == 34) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        _success = !_success;
        _c = $015;
        _pos = $013;
        $01 = $023;
        if (_success) {
          final $026 = _parse$$LITERAL_CHAR(289, $01);
          if (_success) {
            $018 = $026;
          } else {
            _c = $015;
            _pos = $013;
          }
        }
        $012 = $018;
        if (!_success) {
          _success = true;
          break;
        }
        if ($01) {
          $011.add($012);
        }
      }
      if (_c == 34) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        _parse$$SPACING(291, false);
        if (_success) {
          final c = $011;
          Expression $$;
          $$ = LiteralExpression(String.fromCharCodes(c));
          $07 = $$;
        }
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'literal\'']);
    }
    return $02;
  }

  String _parse_members(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    if (_c == 123) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      String $011;
      final $012 = _pos;
      final $013 = $01;
      $01 = false;
      for (;;) {
        _parse$$ACTION_BODY(299, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
      if (_success) {
        $011 = _text.substring($012, _pos);
      }
      $01 = $013;
      if (_c == 125) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        _parse$$SPACING(301, false);
        $07 = $011;
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'members\'']);
    }
    return $02;
  }

  String _parse_$ExclamationMark(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 33) {
      _success = true;
      $010 = '!';
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(305, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'!\'']);
    }
    return $02;
  }

  String _parse_$LeftParenthesis(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 40) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(309, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'(\'']);
    }
    return $02;
  }

  String _parse_$PlusSign(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 43) {
      _success = true;
      $010 = '+';
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(313, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'+\'']);
    }
    return $02;
  }

  String _parse_$Comma(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 44) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(317, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\',\'']);
    }
    return $02;
  }

  String _parse_$QuestionMark(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 63) {
      _success = true;
      $010 = '?';
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(321, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'?\'']);
    }
    return $02;
  }

  String _parse_$Slash(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 47) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(325, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'/\'']);
    }
    return $02;
  }

  String _parse_$Asterisk(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 42) {
      _success = true;
      $010 = '*';
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(329, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'*\'']);
    }
    return $02;
  }

  String _parse_$LessThanSign(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 60) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(333, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'<\'']);
    }
    return $02;
  }

  String _parse_$GreaterThanSign(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $07;
    String $010;
    if (_c == 62) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      _parse$$SPACING(337, false);
      $07 = $010;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $07;
    if (!_success && _error <= _failure) {
      _fail(const ['\'>\'']);
    }
    return $02;
  }

  dynamic _parse$$ACTION_BODY(int $00, bool $01) {
    dynamic $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      String $06;
      final $07 = _c;
      final $08 = _pos;
      String $09;
      if (_c == 123) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        for (;;) {
          _parse$$ACTION_BODY(342, false);
          if (!_success) {
            _success = true;
            break;
          }
        }
        if (_c == 125) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          $06 = $09;
        } else {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      dynamic $013;
      final $014 = _c;
      final $015 = _pos;
      final $018 = $01;
      $01 = false;
      if (_c == 125) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      _success = !_success;
      _c = $014;
      _pos = $015;
      $01 = $018;
      var $020;
      if (_success) {
        if (_c >= 0 && _c <= 1114111) {
          _success = true;
          _c = _input[_pos += _c <= 65535 ? 1 : 2];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          $013 = $020;
        } else {
          _c = $014;
          _pos = $015;
        }
      }
      if (_success) {
        $02 = $013;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    return $02;
  }

  String _parse$$COMMENT(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    final $04 = _c;
    String $06;
    String $09;
    if (_c == 35) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      for (;;) {
        final $012 = _pos;
        final $014 = _c;
        final $021 = $01;
        $01 = false;
        _parse$$EOL(355, false);
        _success = !_success;
        _c = $014;
        _pos = $012;
        $01 = $021;
        if (_success) {
          if (_c >= 0 && _c <= 1114111) {
            _success = true;
            _c = _input[_pos += _c <= 65535 ? 1 : 2];
          } else {
            _success = false;
            _failure = _pos;
          }
          if (!_success) {
            _c = $014;
            _pos = $012;
          }
        }
        if (!_success) {
          _success = true;
          break;
        }
      }
      _parse$$EOL(358, false);
      _success = true;
      $06 = $09;
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    return $02;
  }

  dynamic _parse$$EOL(int $00, bool $01) {
    dynamic $02;
    for (;;) {
      String $06;
      String $09;
      if (_c == 13) {
        $09 = _matchString('\r\n');
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $06 = $09;
        $02 = $06;
        break;
      }
      int $010;
      int $013;
      if (_c == 10 || _c == 13) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $010 = $013;
        $02 = $010;
        break;
      }
      break;
    }
    return $02;
  }

  dynamic _parse$$GLOBALS_BODY(int $00, bool $01) {
    dynamic $02;
    final $03 = _pos;
    final $04 = _c;
    dynamic $06;
    final $011 = $01;
    $01 = false;
    if (_c == 125) {
      _matchString('}%');
    } else {
      _success = false;
      _failure = _pos;
    }
    _success = !_success;
    _c = $04;
    _pos = $03;
    $01 = $011;
    var $013;
    if (_success) {
      if (_c >= 0 && _c <= 1114111) {
        _success = true;
        _c = _input[_pos += _c <= 65535 ? 1 : 2];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $06 = $013;
      } else {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    return $02;
  }

  int _parse$$HEX_NUMBER(int $00, bool $01) {
    int $02;
    final $03 = _pos;
    final $04 = _c;
    int $06;
    if (_c == 92) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      if (_c == 117) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        String $011;
        final $012 = _pos;
        final $013 = $01;
        $01 = false;
        var $023 = false;
        for (;;) {
          if (_c >= 48 && _c <= 57 ||
              _c >= 65 && _c <= 70 ||
              _c >= 97 && _c <= 102) {
            _success = true;
            _c = _input[++_pos];
          } else {
            _success = false;
            _failure = _pos;
          }
          if (!_success) {
            _success = $023;
            break;
          }
          $023 = true;
        }
        if (_success) {
          $011 = _text.substring($012, _pos);
        }
        $01 = $013;
        if (_success) {
          final d = $011;
          int $$;
          $$ = int.parse(d, radix: 16);
          $06 = $$;
        }
      }
      if (!_success) {
        _c = $04;
        _pos = $03;
      }
    }
    $02 = $06;
    return $02;
  }

  String _parse$$IDENTIFIER(int $00, bool $01) {
    String $02;
    final $03 = _pos;
    String $06;
    String $09;
    final $011 = $01;
    $01 = false;
    final $013 = _pos;
    final $015 = _c;
    _parse$$IDENT_START(383, false);
    if (_success) {
      for (;;) {
        _parse$$IDENT_CONT(385, false);
        if (!_success) {
          _success = true;
          break;
        }
      }
      if (!_success) {
        _c = $015;
        _pos = $013;
      }
    }
    if (_success) {
      $09 = _text.substring($03, _pos);
    }
    $01 = $011;
    if (_success) {
      $06 = $09;
    }
    $02 = $06;
    return $02;
  }

  int _parse$$IDENT_CONT(int $00, bool $01) {
    int $02;
    for (;;) {
      int $06;
      final $09 = _parse$$IDENT_START(388, false);
      if (_success) {
        $06 = $09;
        $02 = $06;
        break;
      }
      int $010;
      int $013;
      if (_c >= 48 && _c <= 57 || _c == 95) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $010 = $013;
        $02 = $010;
        break;
      }
      break;
    }
    return $02;
  }

  int _parse$$IDENT_START(int $00, bool $01) {
    int $02;
    int $06;
    int $09;
    if (_c >= 65 && _c <= 90 || _c >= 97 && _c <= 122) {
      _success = true;
      _c = _input[++_pos];
    } else {
      _success = false;
      _failure = _pos;
    }
    if (_success) {
      $06 = $09;
    }
    $02 = $06;
    return $02;
  }

  int _parse$$LITERAL_CHAR(int $00, bool $01) {
    int $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      int $06;
      final $07 = _c;
      final $08 = _pos;
      if (_c == 92) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        int $010;
        if (_c == 34 || _c == 92 || _c == 110 || _c == 114 || _c == 116) {
          _success = true;
          $010 = _c;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          final c = $010;
          int $$;
          $$ = _escape(c);
          $06 = $$;
        }
        if (!_success) {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      int $011;
      final $014 = _parse$$HEX_NUMBER(399, $01);
      if (_success) {
        $011 = $014;
        $02 = $011;
        break;
      }
      int $015;
      final $016 = _c;
      final $017 = _pos;
      final $020 = $01;
      $01 = false;
      if (_c == 92) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      _success = !_success;
      _c = $016;
      _pos = $017;
      $01 = $020;
      if (_success) {
        final $023 = _c;
        final $024 = _pos;
        final $025 = $01;
        $01 = false;
        _parse$$EOL(404, false);
        _success = !_success;
        _c = $023;
        _pos = $024;
        $01 = $025;
        if (_success) {
          int $028;
          if (_c >= 0 && _c <= 1114111) {
            _success = true;
            $028 = _c;
            _c = _input[_pos += _c <= 65535 ? 1 : 2];
          } else {
            _success = false;
            _failure = _pos;
          }
          if (_success) {
            $015 = $028;
          }
        }
        if (!_success) {
          _c = $016;
          _pos = $017;
        }
      }
      if (_success) {
        $02 = $015;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    return $02;
  }

  List<int> _parse$$RANGE(int $00, bool $01) {
    List<int> $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      List<int> $06;
      final $07 = _c;
      final $08 = _pos;
      final $09 = _parse$$RANGE_CHAR(408, $01);
      if (_success) {
        if (_c == 45) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          final $011 = _parse$$RANGE_CHAR(410, $01);
          if (_success) {
            final s = $09;
            final e = $011;
            List<int> $$;
            $$ = [s, e];
            $06 = $$;
          }
        }
        if (!_success) {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      List<int> $012;
      final $015 = _parse$$RANGE_CHAR(412, $01);
      if (_success) {
        final c = $015;
        List<int> $$;
        $$ = [c, c];
        $012 = $$;
      }
      if (_success) {
        $02 = $012;
        break;
      }
      break;
    }
    return $02;
  }

  int _parse$$RANGE_CHAR(int $00, bool $01) {
    int $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      int $06;
      final $07 = _c;
      final $08 = _pos;
      if (_c == 92) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        int $010;
        if (_c >= 92 && _c <= 93 || _c == 110 || _c == 114 || _c == 116) {
          _success = true;
          $010 = _c;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          final c = $010;
          int $$;
          $$ = _escape(c);
          $06 = $$;
        }
        if (!_success) {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      int $011;
      final $014 = _parse$$HEX_NUMBER(418, $01);
      if (_success) {
        $011 = $014;
        $02 = $011;
        break;
      }
      int $015;
      final $016 = _c;
      final $017 = _pos;
      final $020 = $01;
      $01 = false;
      if (_c >= 92 && _c <= 93) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      _success = !_success;
      _c = $016;
      _pos = $017;
      $01 = $020;
      if (_success) {
        final $023 = _c;
        final $024 = _pos;
        final $025 = $01;
        $01 = false;
        _parse$$EOL(423, false);
        _success = !_success;
        _c = $023;
        _pos = $024;
        $01 = $025;
        if (_success) {
          int $028;
          if (_c >= 0 && _c <= 1114111) {
            _success = true;
            $028 = _c;
            _c = _input[_pos += _c <= 65535 ? 1 : 2];
          } else {
            _success = false;
            _failure = _pos;
          }
          if (_success) {
            $015 = $028;
          }
        }
        if (!_success) {
          _c = $016;
          _pos = $017;
        }
      }
      if (_success) {
        $02 = $015;
        break;
      }
      _c = $04;
      _pos = $03;
      break;
    }
    return $02;
  }

  dynamic _parse$$SPACE(int $00, bool $01) {
    dynamic $02;
    for (;;) {
      int $06;
      int $09;
      if (_c == 9 || _c == 32) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $06 = $09;
        $02 = $06;
        break;
      }
      dynamic $010;
      final $013 = _parse$$EOL(429, false);
      if (_success) {
        $010 = $013;
        $02 = $010;
        break;
      }
      break;
    }
    return $02;
  }

  List _parse$$SPACING(int $00, bool $01) {
    List $02;
    for (;;) {
      for (;;) {
        _parse$$SPACE(435, false);
        if (_success) {
          break;
        }
        _parse$$COMMENT(437, false);
        if (_success) {
          break;
        }
        break;
      }
      if (!_success) {
        _success = true;
        break;
      }
    }
    return $02;
  }

  int _parse$$TERMINAL_CHAR(int $00, bool $01) {
    int $02;
    final $03 = _pos;
    final $04 = _c;
    for (;;) {
      int $06;
      final $07 = _c;
      final $08 = _pos;
      if (_c == 47) {
        _matchString('//');
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        int $010;
        if (_c == 39) {
          _success = true;
          _c = _input[++_pos];
        } else {
          _success = false;
          _failure = _pos;
        }
        if (_success) {
          $06 = $010;
        } else {
          _c = $07;
          _pos = $08;
        }
      }
      if (_success) {
        $02 = $06;
        break;
      }
      _c = $04;
      _pos = $03;
      int $011;
      int $014;
      if (_c >= 32 && _c <= 38 || _c >= 40 && _c <= 126) {
        _success = true;
        _c = _input[++_pos];
      } else {
        _success = false;
        _failure = _pos;
      }
      if (_success) {
        $011 = $014;
        $02 = $011;
        break;
      }
      break;
    }
    return $02;
  }
}

class _Memo {
  final int id;

  final int pos;

  final result;

  final bool success;

  _Memo({
    this.id,
    this.pos,
    this.result,
    this.success,
  });
}

// ignore_for_file: unused_element
// ignore_for_file: unused_field
